/********************************************************************************
*                                                                               *
*                           Data Encryption Support                             *
*                                                                               *
*********************************************************************************
*        Copyright (C) 2003-2005 by Niall Douglas.   All Rights Reserved.       *
*       NOTE THAT I DO NOT PERMIT ANY OF MY CODE TO BE PROMOTED TO THE GPL      *
*********************************************************************************
* This code is free software; you can redistribute it and/or modify it under    *
* the terms of the GNU Library General Public License v2.1 as published by the  *
* Free Software Foundation EXCEPT that clause 3 does not apply ie; you may not  *
* "upgrade" this code to the GPL without my prior written permission.           *
* Please consult the file "License_Addendum2.txt" accompanying this file.       *
*                                                                               *
* This code is distributed in the hope that it will be useful,                  *
* but WITHOUT ANY WARRANTY; without even the implied warranty of                *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                          *
*********************************************************************************
* $Id:                                                                          *
********************************************************************************/

#define SEED_SIZE 512				// 4096 bits (this will need to be increased some day)
#define PRIVATEKEY_SIZE 3072

#include "QSSLDevice.h"
#include "FXProcess.h"
#include "FXException.h"
#include "QThread.h"
#include "QTrans.h"
#include "FXRollback.h"
#include "FXFile.h"
#include "FXNetwork.h"
#include "QBuffer.h"
#include "FXErrCodes.h"
#include <qcstring.h>
#ifdef _MSC_VER
#include <malloc.h>			// For alloca()
#endif
#ifdef HAVE_OPENSSL
#include "openssl/err.h"
#include "openssl/bio.h"
#include "openssl/ssl.h"
#include "openssl/rand.h"
#include "openssl/evp.h"
#include "openssl/rsa.h"
#include "openssl/dh.h"
#include "openssl/crypto.h"
#include "openssl/md5.h"
#include <stdio.h>
#endif
#include <assert.h>
//#include "FXMemDbg.h"
#if defined(DEBUG) && defined(FXMEMDBG_H)
static const char *_fxmemdbg_current_file_ = __FILE__;
#endif

#ifdef DEBUG
#undef PRIVATEKEY_SIZE
#define PRIVATEKEY_SIZE 512
#endif

// EVP_MAX_KEY_LENGTH is too small on some OpenSSL's
#if EVP_MAX_KEY_LENGTH<64
#undef EVP_MAX_KEY_LENGTH
#define EVP_MAX_KEY_LENGTH 64
#endif

#define FXERRHSSL(exp) { int __res=(int)(FXuval)(exp); if(__res<=0) { int __errorcode=ERR_get_error(); \
	char __buffer[1024]; ERR_error_string_n(__errorcode, __buffer, sizeof(__buffer)); \
	ERR_clear_error(); \
	if(SSL_R_NO_SHARED_CIPHER==__errorcode) { FXERRG(__buffer, QSSLDEVICE_NOSHAREDCIPHER, 0); } \
	else FXERRGIO(__buffer); } }

namespace FX {

#ifdef HAVE_OPENSSL
/* Generated by reswrap from file dh1024.pem */
static const unsigned char dh1024data[]={
  0x2d,0x2d,0x2d,0x2d,0x2d,0x42,0x45,0x47,0x49,0x4e,0x20,0x44,0x48,0x20,0x50,0x41,
  0x52,0x41,0x4d,0x45,0x54,0x45,0x52,0x53,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,0x4d,0x49,
  0x47,0x48,0x41,0x6f,0x47,0x42,0x41,0x50,0x53,0x49,0x2f,0x56,0x68,0x4f,0x53,0x64,
  0x76,0x4e,0x49,0x4c,0x53,0x64,0x35,0x4a,0x45,0x48,0x4e,0x6d,0x73,0x7a,0x62,0x44,
  0x67,0x4e,0x52,0x52,0x30,0x50,0x66,0x49,0x69,0x7a,0x48,0x48,0x78,0x62,0x4c,0x59,
  0x37,0x32,0x38,0x38,0x6b,0x6a,0x77,0x45,0x50,0x77,0x70,0x56,0x73,0x59,0x0a,0x6a,
  0x59,0x36,0x37,0x56,0x59,0x79,0x34,0x58,0x54,0x6a,0x54,0x4e,0x50,0x31,0x38,0x46,
  0x31,0x64,0x44,0x6f,0x78,0x30,0x59,0x62,0x4e,0x34,0x7a,0x49,0x53,0x79,0x31,0x4b,
  0x76,0x38,0x38,0x34,0x62,0x45,0x70,0x51,0x42,0x67,0x52,0x6a,0x58,0x79,0x45,0x70,
  0x77,0x70,0x79,0x31,0x6f,0x62,0x45,0x41,0x78,0x6e,0x49,0x42,0x79,0x6c,0x36,0x0a,
  0x79,0x70,0x55,0x4d,0x32,0x5a,0x61,0x66,0x71,0x39,0x41,0x4b,0x55,0x4a,0x73,0x43,
  0x52,0x74,0x4d,0x49,0x50,0x57,0x61,0x6b,0x58,0x55,0x47,0x66,0x6e,0x48,0x79,0x39,
  0x69,0x55,0x73,0x69,0x47,0x53,0x61,0x36,0x71,0x36,0x4a,0x65,0x77,0x31,0x58,0x70,
  0x4c,0x33,0x6a,0x48,0x41,0x67,0x45,0x43,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x45,0x4e,
  0x44,0x20,0x44,0x48,0x20,0x50,0x41,0x52,0x41,0x4d,0x45,0x54,0x45,0x52,0x53,0x2d,
  0x2d,0x2d,0x2d,0x2d,0x0a,0x0a,0x54,0x68,0x65,0x73,0x65,0x20,0x61,0x72,0x65,0x20,
  0x74,0x68,0x65,0x20,0x31,0x30,0x32,0x34,0x20,0x62,0x69,0x74,0x20,0x44,0x48,0x20,
  0x70,0x61,0x72,0x61,0x6d,0x65,0x74,0x65,0x72,0x73,0x20,0x66,0x72,0x6f,0x6d,0x20,
  0x22,0x41,0x73,0x73,0x69,0x67,0x6e,0x65,0x64,0x20,0x4e,0x75,0x6d,0x62,0x65,0x72,
  0x20,0x66,0x6f,0x72,0x20,0x53,0x4b,0x49,0x50,0x20,0x50,0x72,0x6f,0x74,0x6f,0x63,
  0x6f,0x6c,0x73,0x22,0x0a,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,
  0x2e,0x73,0x6b,0x69,0x70,0x2d,0x76,0x70,0x6e,0x2e,0x6f,0x72,0x67,0x2f,0x73,0x70,
  0x65,0x63,0x2f,0x6e,0x75,0x6d,0x62,0x65,0x72,0x73,0x2e,0x68,0x74,0x6d,0x6c,0x29,
  0x2e,0x0a,0x53,0x65,0x65,0x20,0x74,0x68,0x65,0x72,0x65,0x20,0x66,0x6f,0x72,0x20,
  0x68,0x6f,0x77,0x20,0x74,0x68,0x65,0x79,0x20,0x77,0x65,0x72,0x65,0x20,0x67,0x65,
  0x6e,0x65,0x72,0x61,0x74,0x65,0x64,0x2e,0x0a,0x4e,0x6f,0x74,0x65,0x20,0x74,0x68,
  0x61,0x74,0x20,0x67,0x20,0x69,0x73,0x20,0x6e,0x6f,0x74,0x20,0x61,0x20,0x67,0x65,
  0x6e,0x65,0x72,0x61,0x74,0x6f,0x72,0x2c,0x20,0x62,0x75,0x74,0x20,0x74,0x68,0x69,
  0x73,0x20,0x69,0x73,0x20,0x6e,0x6f,0x74,0x20,0x61,0x20,0x70,0x72,0x6f,0x62,0x6c,
  0x65,0x6d,0x20,0x73,0x69,0x6e,0x63,0x65,0x20,0x70,0x20,0x69,0x73,0x20,0x61,0x20,
  0x73,0x61,0x66,0x65,0x20,0x70,0x72,0x69,0x6d,0x65,0x2e,0x0a
  };

/* Generated by reswrap from file dh4096.pem */
static const unsigned char dh4096data[]={
  0x2d,0x2d,0x2d,0x2d,0x2d,0x42,0x45,0x47,0x49,0x4e,0x20,0x44,0x48,0x20,0x50,0x41,
  0x52,0x41,0x4d,0x45,0x54,0x45,0x52,0x53,0x2d,0x2d,0x2d,0x2d,0x2d,0x0a,0x4d,0x49,
  0x49,0x43,0x43,0x41,0x4b,0x43,0x41,0x67,0x45,0x41,0x2b,0x68,0x52,0x79,0x55,0x73,
  0x46,0x4e,0x34,0x56,0x70,0x4a,0x31,0x4f,0x38,0x4a,0x4c,0x63,0x43,0x6f,0x2f,0x56,
  0x57,0x72,0x31,0x39,0x6b,0x33,0x42,0x43,0x67,0x4a,0x34,0x75,0x6b,0x2b,0x64,0x2b,
  0x4b,0x68,0x65,0x68,0x6a,0x64,0x52,0x71,0x4e,0x44,0x4e,0x79,0x4f,0x51,0x0a,0x6c,
  0x2f,0x4d,0x4f,0x79,0x51,0x4e,0x51,0x66,0x57,0x58,0x50,0x65,0x47,0x4b,0x6d,0x4f,
  0x6d,0x49,0x69,0x67,0x36,0x45,0x76,0x2f,0x6e,0x6d,0x36,0x4e,0x66,0x39,0x5a,0x32,
  0x42,0x31,0x68,0x33,0x52,0x34,0x68,0x45,0x78,0x66,0x2b,0x7a,0x54,0x69,0x48,0x6e,
  0x76,0x56,0x50,0x65,0x52,0x42,0x68,0x6a,0x64,0x51,0x69,0x38,0x31,0x72,0x74,0x0a,
  0x58,0x65,0x6f,0x68,0x36,0x54,0x4e,0x72,0x53,0x42,0x49,0x4b,0x49,0x48,0x66,0x55,
  0x4a,0x57,0x42,0x68,0x33,0x76,0x61,0x30,0x54,0x78,0x78,0x6a,0x51,0x49,0x73,0x36,
  0x49,0x5a,0x4f,0x4c,0x65,0x56,0x4e,0x52,0x4c,0x4d,0x71,0x7a,0x65,0x79,0x6c,0x57,
  0x71,0x4d,0x66,0x34,0x39,0x48,0x73,0x49,0x58,0x71,0x62,0x63,0x6f,0x6b,0x55,0x53,
  0x0a,0x56,0x74,0x31,0x42,0x6b,0x76,0x4c,0x64,0x57,0x34,0x38,0x6a,0x38,0x50,0x50,
  0x76,0x35,0x44,0x73,0x4b,0x52,0x4e,0x33,0x74,0x6c,0x6f,0x54,0x78,0x71,0x44,0x4a,
  0x47,0x6f,0x39,0x74,0x4b,0x76,0x6a,0x31,0x46,0x75,0x6b,0x37,0x34,0x41,0x2b,0x58,
  0x64,0x61,0x31,0x6b,0x4e,0x68,0x42,0x37,0x4b,0x46,0x6c,0x71,0x4d,0x79,0x4e,0x39,
  0x38,0x0a,0x56,0x45,0x54,0x45,0x4a,0x36,0x63,0x37,0x4b,0x70,0x66,0x4f,0x6f,0x33,
  0x30,0x6d,0x6e,0x4b,0x33,0x30,0x77,0x71,0x77,0x33,0x53,0x38,0x4f,0x74,0x61,0x49,
  0x52,0x2f,0x6d,0x61,0x59,0x58,0x37,0x32,0x74,0x47,0x4f,0x6e,0x6f,0x32,0x65,0x68,
  0x46,0x44,0x6b,0x71,0x33,0x70,0x6e,0x50,0x74,0x45,0x62,0x44,0x32,0x43,0x53,0x63,
  0x78,0x63,0x0a,0x61,0x6c,0x4a,0x43,0x2b,0x45,0x4c,0x37,0x52,0x50,0x6b,0x35,0x63,
  0x2f,0x74,0x67,0x65,0x54,0x76,0x43,0x6e,0x67,0x76,0x63,0x31,0x4b,0x5a,0x6e,0x39,
  0x32,0x59,0x2f,0x2f,0x45,0x49,0x37,0x47,0x39,0x74,0x50,0x5a,0x74,0x79,0x6c,0x6a,
  0x32,0x62,0x35,0x36,0x73,0x48,0x74,0x4d,0x66,0x74,0x49,0x6f,0x59,0x4a,0x39,0x2b,
  0x4f,0x44,0x4d,0x0a,0x73,0x63,0x63,0x44,0x35,0x50,0x69,0x7a,0x2f,0x72,0x65,0x6a,
  0x45,0x33,0x4f,0x6d,0x65,0x38,0x45,0x4f,0x4f,0x63,0x65,0x55,0x53,0x43,0x59,0x41,
  0x68,0x58,0x6e,0x38,0x62,0x33,0x71,0x76,0x78,0x56,0x49,0x31,0x64,0x64,0x64,0x31,
  0x70,0x45,0x44,0x36,0x46,0x48,0x52,0x68,0x46,0x76,0x4c,0x72,0x5a,0x78,0x46,0x76,
  0x42,0x45,0x4d,0x39,0x0a,0x45,0x52,0x52,0x4d,0x70,0x35,0x51,0x71,0x4f,0x61,0x48,
  0x4a,0x6b,0x4d,0x2b,0x44,0x78,0x76,0x38,0x43,0x6a,0x36,0x4d,0x71,0x72,0x43,0x62,
  0x66,0x43,0x34,0x75,0x2b,0x5a,0x45,0x72,0x78,0x6f,0x64,0x7a,0x75,0x75,0x73,0x67,
  0x44,0x67,0x76,0x5a,0x69,0x4c,0x46,0x32,0x32,0x75,0x78,0x4d,0x5a,0x62,0x6f,0x62,
  0x46,0x57,0x79,0x74,0x65,0x0a,0x4f,0x76,0x4f,0x7a,0x4b,0x47,0x74,0x77,0x63,0x54,
  0x71,0x4f,0x2f,0x31,0x77,0x56,0x35,0x67,0x4b,0x6b,0x7a,0x75,0x31,0x5a,0x56,0x73,
  0x77,0x56,0x55,0x51,0x64,0x35,0x47,0x67,0x38,0x6c,0x4a,0x69,0x63,0x77,0x71,0x52,
  0x57,0x79,0x79,0x4e,0x52,0x63,0x7a,0x44,0x44,0x6f,0x47,0x39,0x6a,0x56,0x44,0x78,
  0x6d,0x6f,0x67,0x4b,0x54,0x48,0x0a,0x41,0x61,0x71,0x4c,0x75,0x6c,0x4f,0x37,0x52,
  0x38,0x49,0x66,0x61,0x31,0x53,0x77,0x46,0x32,0x44,0x74,0x65,0x53,0x47,0x56,0x74,
  0x67,0x57,0x45,0x4e,0x38,0x67,0x44,0x70,0x4e,0x33,0x52,0x42,0x6d,0x6d,0x50,0x54,
  0x44,0x6e,0x67,0x79,0x46,0x32,0x44,0x48,0x62,0x35,0x71,0x6d,0x70,0x6e,0x7a,0x6e,
  0x77,0x74,0x46,0x4b,0x64,0x54,0x4c,0x0a,0x4b,0x57,0x62,0x75,0x48,0x6e,0x34,0x39,
  0x31,0x78,0x4e,0x4f,0x32,0x35,0x43,0x51,0x57,0x4d,0x74,0x65,0x6d,0x38,0x30,0x75,
  0x4b,0x77,0x2b,0x70,0x54,0x6e,0x69,0x73,0x42,0x52,0x46,0x2f,0x34,0x35,0x34,0x6e,
  0x31,0x4a,0x6e,0x68,0x75,0x62,0x31,0x34,0x34,0x59,0x52,0x42,0x6f,0x4e,0x38,0x43,
  0x41,0x51,0x49,0x3d,0x0a,0x2d,0x2d,0x2d,0x2d,0x2d,0x45,0x4e,0x44,0x20,0x44,0x48,
  0x20,0x50,0x41,0x52,0x41,0x4d,0x45,0x54,0x45,0x52,0x53,0x2d,0x2d,0x2d,0x2d,0x2d,
  0x0a,0x0a,0x54,0x68,0x65,0x73,0x65,0x20,0x61,0x72,0x65,0x20,0x74,0x68,0x65,0x20,
  0x34,0x30,0x39,0x36,0x20,0x62,0x69,0x74,0x20,0x44,0x48,0x20,0x70,0x61,0x72,0x61,
  0x6d,0x65,0x74,0x65,0x72,0x73,0x20,0x66,0x72,0x6f,0x6d,0x20,0x22,0x41,0x73,0x73,
  0x69,0x67,0x6e,0x65,0x64,0x20,0x4e,0x75,0x6d,0x62,0x65,0x72,0x20,0x66,0x6f,0x72,
  0x20,0x53,0x4b,0x49,0x50,0x20,0x50,0x72,0x6f,0x74,0x6f,0x63,0x6f,0x6c,0x73,0x22,
  0x0a,0x28,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x73,0x6b,0x69,
  0x70,0x2d,0x76,0x70,0x6e,0x2e,0x6f,0x72,0x67,0x2f,0x73,0x70,0x65,0x63,0x2f,0x6e,
  0x75,0x6d,0x62,0x65,0x72,0x73,0x2e,0x68,0x74,0x6d,0x6c,0x29,0x2e,0x0a,0x53,0x65,
  0x65,0x20,0x74,0x68,0x65,0x72,0x65,0x20,0x66,0x6f,0x72,0x20,0x68,0x6f,0x77,0x20,
  0x74,0x68,0x65,0x79,0x20,0x77,0x65,0x72,0x65,0x20,0x67,0x65,0x6e,0x65,0x72,0x61,
  0x74,0x65,0x64,0x2e,0x0a,0x4e,0x6f,0x74,0x65,0x20,0x74,0x68,0x61,0x74,0x20,0x67,
  0x20,0x69,0x73,0x20,0x6e,0x6f,0x74,0x20,0x61,0x20,0x67,0x65,0x6e,0x65,0x72,0x61,
  0x74,0x6f,0x72,0x2c,0x20,0x62,0x75,0x74,0x20,0x74,0x68,0x69,0x73,0x20,0x69,0x73,
  0x20,0x6e,0x6f,0x74,0x20,0x61,0x20,0x70,0x72,0x6f,0x62,0x6c,0x65,0x6d,0x20,0x73,
  0x69,0x6e,0x63,0x65,0x20,0x70,0x20,0x69,0x73,0x20,0x61,0x20,0x73,0x61,0x66,0x65,
  0x20,0x70,0x72,0x69,0x6d,0x65,0x2e,0x0a
  };

static FXString getSSLError()
{
	char buffer[1024];
	ERR_error_string_n(ERR_get_error(), buffer, sizeof(buffer));
	return FXString(buffer);
}

static DH *dh512, *dh1024, *dh4096;
static DH *getDHParams(SSL *ssl, int isexport, int keylen)
{
	switch(keylen)
	{	// TODO: Add 2048 bits, also need to generate new ones
		// of these myself to prevent known primes attack
	case 512:
		{
			return (dh512=DH_generate_parameters(512, 5, NULL, 0));
		}
	case 1024:
		return dh1024;
	case 4096:
		return dh4096;
	}
	return NULL;
}

#endif

class QSSLDevice_Init;
static QSSLDevice_Init *myinit;
class QSSLDevice_Init : public QMutex
{
public:
#ifdef HAVE_OPENSSL
	SSL_CTX *ctx;
	QMemArray<QMutex *> locks;
	static void lockingfunction(int mode, int n, const char *file, int line)
	{
		if(!myinit) return;
		QMutex *m=myinit->locks.at(n);
		assert(m);
		if(mode & CRYPTO_LOCK) m->lock(); else m->unlock();
	}
#endif
	QSSLDevice_Init()
#ifndef HAVE_OPENSSL
	{
#else
		: ctx(0), locks(CRYPTO_num_locks())
	{
		SSL_load_error_strings();
		FXERRHSSL(SSL_library_init());
		for(FXuint n=0; n<locks.size(); n++)
		{
			FXERRHM(locks[n]=new QMutex);
		}
		CRYPTO_set_locking_callback(lockingfunction);
		myinit=this;
#endif
	}
	void setup()
	{
#ifdef HAVE_OPENSSL
		QMtxHold h(this);
		if(!ctx) 
		{
			if(Secure::Randomness::size()<SEED_SIZE)
			{
#ifdef WIN32
				RAND_screen();
#else
				FXERRHSSL(RAND_poll());
#endif
			}
			{
				FXuchar buffer[SEED_SIZE];
				FXuval size=Secure::Randomness::readBlock(buffer, FXMIN(SEED_SIZE, Secure::Randomness::size()));
				RAND_seed(buffer, (FXuint) size);
			}
			if(!(ctx=SSL_CTX_new(SSLv23_method()))) FXERRHSSL(-1);
			FXERRHSSL(SSL_CTX_set_options(ctx, SSL_OP_SINGLE_DH_USE));
			{	// Read dh1024
				BIO *h=BIO_new_mem_buf((void *) dh1024data, sizeof(dh1024data));
				FXRBOp unh=FXRBFunc(BIO_free, h);
				if(!(dh1024=PEM_read_bio_DHparams(h, NULL, NULL, NULL))) FXERRHSSL(-1);
			}
			{	// Read dh4096
				BIO *h=BIO_new_mem_buf((void *) dh4096data, sizeof(dh4096data));
				FXRBOp unh=FXRBFunc(BIO_free, h);
				if(!(dh4096=PEM_read_bio_DHparams(h, NULL, NULL, NULL))) FXERRHSSL(-1);
			}
			SSL_CTX_set_tmp_dh_callback(ctx, getDHParams);
			FXERRHSSL(SSL_CTX_set_cipher_list(ctx, "ALL:@STRENGTH"));
			SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER, 0);
			SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY|SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);
			FXString myname("TnFOX_%1_%2");
			myname.arg(FXNetwork::hostname()).arg(FXProcess::id(), 0, 16);
			FXERRHSSL(SSL_CTX_set_session_id_context(ctx, (unsigned char *) myname.text(), myname.length()));
		}
#endif
	}
	~QSSLDevice_Init()
	{
#ifdef HAVE_OPENSSL
		QMtxHold h(this);
		if(ctx)
		{
			SSL_CTX_free(ctx);
			ctx=0;
		}
		if(dh4096)
		{
			DH_free(dh4096);
			dh4096=0;
		}
		if(dh1024)
		{
			DH_free(dh1024);
			dh1024=0;
		}
		if(dh512)
		{
			DH_free(dh512);
			dh512=0;
		}
		ERR_free_strings();
		for(FXuint n=0; n<locks.size(); n++)
		{
			FXDELETE(locks[n]);
		}
		locks.resize(0);
		myinit=0;
#endif
	}
};
static FXProcess_StaticInit<QSSLDevice_Init> mystaticinit("QSSLDevice");

#ifdef HAVE_OPENSSL
namespace Wrap {
#define TRAPFXERR1 try
#ifdef DEBUG
#define TRAPFXERR2(type1) catch(FXException &) { \
	ERR_put_error(ERR_LIB_BIO,type1,0,__FILE__,__LINE__); \
	return -1; \
	} \
	catch(...) { \
	fxmessage("\nWARNING: Unknown exception about to pass through C-based OpenSSL code!\n"); \
	/*std::terminate();*/ /* You REALLY don't want exception based thread cancellation going through OpenSSL written in C */ \
	throw; \
	}
#else
#define TRAPFXERR2(type1) catch(FXException &) { \
	ERR_put_error(ERR_LIB_BIO,type1,0,__FILE__,__LINE__); \
	return -1; \
	}
#endif

static int bwrite(BIO *b, const char *buffer, int len)
{
	QIODevice *dev=(QIODevice *) b->ptr;
	TRAPFXERR1 {
		//printf("bwrite %s", fxdump8((FXuchar *) buffer, len).text());
		return (int) dev->writeBlock(buffer, len);
	} TRAPFXERR2(BIO_F_BIO_WRITE);
}
static int bread(BIO *b, char *buffer, int len)
{
	QIODevice *dev=(QIODevice *) b->ptr;
	TRAPFXERR1 {
		int read=(int) dev->readBlock(buffer, len);
		//printf("bread %s", fxdump8((FXuchar *) buffer, read).text());
		return read;
	} TRAPFXERR2(BIO_F_BIO_READ);
}
static int bputs(BIO *b, const char *buffer)
{
	int len=(int) strlen(buffer);
	QIODevice *dev=(QIODevice *) b->ptr;
	TRAPFXERR1 {
		return (int) dev->writeBlock(buffer, len);
	} TRAPFXERR2(BIO_F_BIO_WRITE);
}
static long ctrl(BIO *b, int cmd, long num, void *ptr)
{
	QIODevice *dev=(QIODevice *) b->ptr;
	long ret=1;
	TRAPFXERR1 {
		switch(cmd)
		{
		case BIO_CTRL_RESET:
				num=0;
		case BIO_C_FILE_SEEK:
			{
				ret=(long) dev->at(num);
				break;
			}
		case BIO_CTRL_EOF:
			{
				ret=(long) dev->atEnd();
				break;
			}
		case BIO_C_FILE_TELL:
		case BIO_CTRL_INFO:
			{
				ret=(long) dev->at();
				break;
			}
		case BIO_C_SET_FILE_PTR:
			{
				b->num=0;
				b->ptr=ptr;
				b->init=1;
				break;
			}
		case BIO_C_GET_FILE_PTR:
			{
				if(b->init)
				{
					QIODevice **dev=(QIODevice **) ptr;
					if(dev) *dev=(QIODevice *) b->ptr;
				}
				else ret=-1;
				break;
			}
		case BIO_CTRL_FLUSH:
			{
				dev->flush();
				break;
			}
		case BIO_CTRL_GET_CLOSE:
			ret=0;
			break;
		case BIO_CTRL_SET_CLOSE:
			break;
		case BIO_CTRL_DUP:
			ret=1;
			break;
		case BIO_CTRL_WPENDING:
		case BIO_CTRL_PENDING:
		//case BIO_CTRL_PUSH:
		//case BIO_CTRL_POP:
		default:
			ret=0;
			break;
		}
		return ret;
	} TRAPFXERR2(BIO_F_BIO_CTRL);
}
static int create(BIO *b)
{
	b->init=0;
	b->num=0;
	b->ptr=NULL;
	return 1;
}
static int destroy(BIO *b)
{
	if(!b) return 0;
	b->ptr=0;
	b->init=0;
	return 1;
}
} // namespace
static BIO_METHOD BIO_s_QIODevice={
	64|BIO_TYPE_SOURCE_SINK,	// custom type
	"QIODevice wrapper",
	Wrap::bwrite,
	Wrap::bread,
	Wrap::bputs,
	NULL, // Wrap::bgets,
	Wrap::ctrl,
	Wrap::create,
	Wrap::destroy,
	NULL  //Wrap::callback_ctrl
};
#endif


class FXSSLPKeyPrivate
{
public:
	FXuint bitsize;
	FXSSLPKey::KeyType type;
	union Keys_t
	{
		void *contents;
#ifdef HAVE_OPENSSL
		RSA *rsa;
		DH *dh;
#endif
	} key;
	FXSSLPKeyPrivate(FXuint _bitsize, FXSSLPKey::KeyType _type) : bitsize(_bitsize), type(_type) { key.contents=0; }
	void copy(const FXSSLPKeyPrivate &o, int what=0)		// what=1 for private, 2 for public
	{
		bitsize=o.bitsize;
		type=o.type;
#ifdef HAVE_OPENSSL
		switch(type)
		{
		case FXSSLPKey::RSA:
			{
				if(!key.rsa)
				{
					if(!(key.rsa=RSA_new())) FXERRHSSL(-1);
					if(!what || 1==what)
					{
						if(o.key.rsa->d) { if(!(key.rsa->d=BN_dup(o.key.rsa->d))) FXERRHSSL(-1); }
						if(o.key.rsa->p) { if(!(key.rsa->p=BN_dup(o.key.rsa->p))) FXERRHSSL(-1); }
						if(o.key.rsa->q) { if(!(key.rsa->q=BN_dup(o.key.rsa->q))) FXERRHSSL(-1); }
						if(o.key.rsa->dmp1) { if(!(key.rsa->dmp1=BN_dup(o.key.rsa->dmp1))) FXERRHSSL(-1); }
						if(o.key.rsa->dmq1) { if(!(key.rsa->dmq1=BN_dup(o.key.rsa->dmq1))) FXERRHSSL(-1); }
					}
					if(!what)
					{
						if(o.key.rsa->iqmp) { if(!(key.rsa->iqmp=BN_dup(o.key.rsa->iqmp))) FXERRHSSL(-1); }
					}
					if(!what || 2==what)
					{
						if(o.key.rsa->n) { if(!(key.rsa->n=BN_dup(o.key.rsa->n))) FXERRHSSL(-1); }
						if(o.key.rsa->e) { if(!(key.rsa->e=BN_dup(o.key.rsa->e))) FXERRHSSL(-1); }
					}
				}
				break;
			}
		case FXSSLPKey::DH:
			{
				if(!key.dh)
				{
					if(!(key.dh=DH_new())) FXERRHSSL(-1);
					if(!what)
					{
						if(!(key.dh->p=BN_dup(o.key.dh->p))) FXERRHSSL(-1);
						if(!(key.dh->g=BN_dup(o.key.dh->g))) FXERRHSSL(-1);
					}
					if(!what || 1==what) { if(!(key.dh->priv_key=BN_dup(o.key.dh->priv_key))) FXERRHSSL(-1); }
					if(!what || 2==what) { if(!(key.dh->pub_key=BN_dup(o.key.dh->pub_key))) FXERRHSSL(-1); }
				}
				break;
			}
		}
#endif
	}
	void clear()
	{
		if(key.contents)
		{
#ifdef HAVE_OPENSSL
			switch(type)
			{
			case FXSSLPKey::RSA:
				{
					RSA_free(key.rsa);
					break;
				}
			case FXSSLPKey::DH:
				{
					DH_free(key.dh);
					break;
				}
			}
#endif
			key.contents=0;
		}
	}
};

FXSSLPKey::FXSSLPKey(FXuint bitsize, FXSSLPKey::KeyType type) : p(0)
{
	FXRBOp unconstr=FXRBConstruct(this);
	FXERRHM(p=new FXSSLPKeyPrivate(bitsize, type));
	if(NoEncryption!=type) generate();
	unconstr.dismiss();
}

FXSSLPKey::~FXSSLPKey()
{ FXEXCEPTIONDESTRUCT1 {
	if(p)
	{
		p->clear();
		FXDELETE(p);
	}
} FXEXCEPTIONDESTRUCT2; }

FXSSLPKey::FXSSLPKey(const FXSSLPKey &o) : p(0)
{
	FXERRHM(p=new FXSSLPKeyPrivate(o.p->bitsize, o.p->type));
	p->copy(*o.p);
}

FXSSLPKey &FXSSLPKey::operator=(const FXSSLPKey &o)
{
	p->clear();
	p->copy(*o.p);
	return *this;
}

bool FXSSLPKey::operator==(const FXSSLPKey &o) const
{
	if(p->bitsize==o.p->bitsize && p->type==o.p->type)
	{
		if(!p->key.contents && !o.p->key.contents) return true;
		if(p->key.contents && o.p->key.contents)
		{
#ifdef HAVE_OPENSSL
			switch(p->type)
			{
			case RSA:
				{
					if(p->key.rsa->n && o.p->key.rsa->n && BN_cmp(p->key.rsa->n, o.p->key.rsa->n)) return false;
					if(p->key.rsa->e && o.p->key.rsa->e && BN_cmp(p->key.rsa->e, o.p->key.rsa->e)) return false;
					if(p->key.rsa->d && o.p->key.rsa->d && BN_cmp(p->key.rsa->d, o.p->key.rsa->d)) return false;
					return true;
				}
			}
#endif
		}
	}
	return false;
}
bool FXSSLPKey::operator<(const FXSSLPKey &other) const
{
	if(p->bitsize<other.p->bitsize) return true;
	if(p->key.contents && !other.p->key.contents) return true;
	if(!p->key.contents && other.p->key.contents) return false;
#ifdef HAVE_OPENSSL
	switch(p->type)
	{
	case RSA:
		{
			if(p->key.rsa->n && other.p->key.rsa->n && BN_cmp(p->key.rsa->n, other.p->key.rsa->n)>0) return false;
			if(p->key.rsa->e && other.p->key.rsa->e && BN_cmp(p->key.rsa->e, other.p->key.rsa->e)>0) return false;
			if(p->key.rsa->d && other.p->key.rsa->d && BN_cmp(p->key.rsa->d, other.p->key.rsa->d)>0) return false;
			return true;
		}
	}
#endif
	return false;
}

FXSSLPKey::KeyType FXSSLPKey::type() const throw()
{
	return p->type;
}

void FXSSLPKey::setType(FXSSLPKey::KeyType type)
{
	if(type!=p->type) p->clear();
	p->type=type;
}

FXString FXSSLPKey::typeAsString() const
{
	switch(p->type)
	{
	case NoEncryption:
		return FXString("None");
	case RSA:
		return FXString("RSA");
	}
	return FXString();
}

FXuint FXSSLPKey::bytesLen() const throw()
{
	return (7+p->bitsize)/8;
}

FXuint FXSSLPKey::bitsLen() const throw()
{
	return p->bitsize;
}

void FXSSLPKey::setBitsLen(FXuint newsize)
{
	if(newsize!=p->bitsize)
	{
		p->clear();
		p->bitsize=newsize;
	}
}

bool FXSSLPKey::hasPublicKey() const throw()
{
#ifdef HAVE_OPENSSL
	switch(p->type)
	{
	case RSA:
		{
			return p->key.rsa->n && p->key.rsa->e;
		}
	case DH:
		{
			return p->key.dh->pub_key!=0;
		}
	}
#endif
	return false;
}

FXSSLPKey FXSSLPKey::publicKey() const
{
	FXSSLPKey ret(p->bitsize);
	ret.p->copy(*p, 2);
	return ret;
}

FXString FXSSLPKey::publicKeyAsString() const
{
	if(hasPublicKey())
	{
#ifdef HAVE_OPENSSL
		switch(p->type)
		{
		case FXSSLPKey::RSA:
			{
				char *mod, *exp;
				if(!(mod=BN_bn2hex(p->key.rsa->n))) FXERRHSSL(-1);
				FXRBOp unmod=FXRBFunc(OPENSSL_freeFunc, mod);
				if(!(exp=BN_bn2hex(p->key.rsa->e))) FXERRHSSL(-1);
				FXRBOp unexp=FXRBFunc(OPENSSL_freeFunc, exp);
				return "m0x"+FXString(mod)+",e0x"+FXString(exp);
			}
		}
#endif
	}
	return FXString::nullStr();
}

Secure::TigerHashValue FXSSLPKey::publicKeyAsHash() const
{
	Secure::TigerHashValue ret;
	memset(ret.data.bytes, 0, sizeof(Secure::TigerHashValue));
	if(hasPublicKey())
	{
		FXuchar *buffer;
		FXERRHM(buffer=Secure::malloc<FXuchar>(8192));
		FXRBOp unbuffer=FXRBFunc(&Secure::free<FXuchar>, buffer);
#ifdef HAVE_OPENSSL
		switch(p->type)
		{
		case FXSSLPKey::RSA:
			{
				FXuint len;
				len=(FXuint) BN_bn2bin(p->key.rsa->n, buffer);
				len+=(FXuint) BN_bn2bin(p->key.rsa->e, buffer+len);
				ret=Secure::TigerHash().calc(buffer, len);
				break;
			}
		}
#endif
	}
	return ret;
}

bool FXSSLPKey::hasPrivateKey() const throw()
{
#ifdef HAVE_OPENSSL
	switch(p->type)
	{
	case RSA:
		{
			return p->key.rsa->d!=0;
		}
	case DH:
		{
			return p->key.dh->priv_key!=0;
		}
	}
#endif
	return false;
}

FXSSLPKey FXSSLPKey::privateKey() const
{
	FXSSLPKey ret(p->bitsize);
	ret.p->copy(*p, 1);
	return ret;
}

void FXSSLPKey::generate()
{
#ifdef HAVE_OPENSSL
	{
		FXuchar buffer[SEED_SIZE];
		FXuval keysize=(7+p->bitsize)/8;
		FXuval size=Secure::Randomness::readBlock(buffer, FXMIN(keysize, Secure::Randomness::size()));
		RAND_seed(buffer, (FXuint) size);
	}
	switch(p->type)
	{
	case NoEncryption:
		break;
	case RSA:
		{
			if(p->key.rsa) RSA_free(p->key.rsa);
			if(!(p->key.rsa=RSA_generate_key(p->bitsize, RSA_F4, NULL, 0))) FXERRHSSL(-1);
			FXERRHSSL(RSA_blinding_on(p->key.rsa, NULL));
			break;
		}
	case DH:
		{
			::DH *basedh=getDHParams(0, 0, p->bitsize);
			if(basedh)
			{
				if(!(p->key.dh=DH_new())) FXERRHSSL(-1);
				if(!(p->key.dh->p=BN_dup(basedh->p))) FXERRHSSL(-1);
				if(!(p->key.dh->g=BN_dup(basedh->g))) FXERRHSSL(-1);
			}
			else if(!p->key.dh)		// Skip it if primes already generated
			{
				if(!(p->key.dh=DH_generate_parameters(p->bitsize, 5, NULL, 0))) FXERRHSSL(-1);
			}
			if(p->key.dh->priv_key)
			{
				BN_free(p->key.dh->priv_key);
				p->key.dh->priv_key=0;
			}
			FXERRHSSL(DH_generate_key(p->key.dh));
			break;
		}
	}
#endif
}

bool FXSSLPKey::verify() const
{
	if(!(hasPublicKey() && hasPrivateKey())) return true;
#ifdef HAVE_OPENSSL
	switch(p->type)
	{
	case RSA:
		{
			int ret=RSA_check_key(p->key.rsa);
			if(ret<0) FXERRHSSL(ret);
			return (ret==1);
		}
	}
#endif
	return false;
}

void FXSSLPKey::readFromPEM(QIODevice *dev)
{
#ifdef HAVE_OPENSSL
	BIO *bio;
	if(!(bio=BIO_new(&BIO_s_QIODevice))) FXERRHSSL(-1);
	FXRBOp unbio=FXRBFunc(BIO_free_all, bio);
	BIO_set_fp(bio, dev, 0);
	p->clear();
	p->type=RSA;	// TODO: Other PEM formats
	{
		::RSA *publickey=0, *privatekey=0;
		publickey=PEM_read_bio_RSAPublicKey(bio, NULL, NULL, 0);
		privatekey=PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, 0);
		FXERRH(publickey || privatekey, QTrans::tr("FXSSLKey", "Failed to read RSA public or private key from PEM file"), FXSSLKEY_PEMNODATA, 0);
		if(privatekey)
		{
			p->key.rsa=privatekey;
			if(publickey)
			{	// Merge
				p->key.rsa->n=publickey->n; publickey->n=0;
				p->key.rsa->e=publickey->e; publickey->e=0;
				RSA_free(publickey);
			}
		}
		else
		{
			p->key.rsa=publickey;
		}
	}
#endif
}

void FXSSLPKey::writeAsPEM(QIODevice *dev) const
{
#ifdef HAVE_OPENSSL
	BIO *bio;
	if(!(bio=BIO_new(&BIO_s_QIODevice))) FXERRHSSL(-1);
	FXRBOp unbio=FXRBFunc(BIO_free_all, bio);
	BIO_set_fp(bio, dev, 0);
	switch(p->type)
	{
	case RSA:
		{
			if(hasPublicKey())
			{
				FXERRHSSL(PEM_write_bio_RSAPublicKey(bio, p->key.rsa));
			}
			if(hasPrivateKey())
			{
				FXERRHSSL(PEM_write_bio_RSAPrivateKey(bio, p->key.rsa, NULL, NULL, 0, NULL, 0));
			}
			break;
		}
	}
#endif
}

FXSSLPKey FXSSLPKey::publicKeyFromString(const FXString &s, FXSSLPKey::KeyType keytype)
{
	FXint mpos=s.find("m0x"), epos=s.find(",e0x");
	FXString mantissa(s.mid(mpos+3, epos-mpos+3)), exponent(s.mid(epos+4));
	FXSSLPKey ret(0);
#ifdef HAVE_OPENSSL
	if(mpos>=0 && epos>=0)
	{
		switch(keytype)
		{
		case FXSSLPKey::RSA:
			{
				ret.p->type=keytype;
				// Try to guess the length based on the mantissa length
				// Round up to the nearest power of two
				FXuint bits=mantissa.length()*4;	// Four bits per char in hex
				int n;
				for(n=-1; bits!=0; n++) bits>>=1;
				ret.p->bitsize=1<<n;
				if(!(ret.p->key.rsa=RSA_new())) FXERRHSSL(-1);
				FXERRHSSL(BN_hex2bn(&ret.p->key.rsa->n, mantissa.text()));
				FXERRHSSL(BN_hex2bn(&ret.p->key.rsa->e, exponent.text()));
				return ret;
			}
		}
	}
#endif
	return ret;
}

FXStream &operator<<(FXStream &s, const FXSSLPKey &i)
{
#ifdef HAVE_OPENSSL
	s << i.p->bitsize << (FXushort) i.p->type;
	FXuchar *buffer;
	FXERRHM(buffer=Secure::malloc<FXuchar>(4096));
	FXRBOp unbuffer=FXRBFunc(&Secure::free<FXuchar>, buffer);
	switch(i.p->type)
	{
	case FXSSLPKey::RSA:
		{
			FXuint len=0;
			if(i.hasPublicKey())
			{
				s.writeRawBytes("PUB1", 4);
				len=(FXuint) BN_bn2bin(i.p->key.rsa->n, buffer);
				s << len; s.writeRawBytes(buffer, len);
				len=(FXuint) BN_bn2bin(i.p->key.rsa->e, buffer);
				s << len; s.writeRawBytes(buffer, len);
			}
			if(i.hasPrivateKey())
			{
				s.writeRawBytes("PRV1", 4);
				len=(FXuint) BN_bn2bin(i.p->key.rsa->d, buffer);
				s << len; s.writeRawBytes(buffer, len);
			}
			break;
		}
	}
	s.writeRawBytes("ENDK", 4);
#endif
	return s;
}

FXStream &operator>>(FXStream &s, FXSSLPKey &i)
{
#ifdef HAVE_OPENSSL
	i.p->clear();
	FXushort type;
	s >> i.p->bitsize;
	s >> type;
	i.p->type=(FXSSLPKey::KeyType) type;
	FXuint tag;
	FXuchar *buffer;
	FXERRHM(buffer=Secure::malloc<FXuchar>(4096));
	FXRBOp unbuffer=FXRBFunc(&Secure::free<FXuchar>, buffer);
	do
	{
		FXuint len;
		s.readRawBytes((char *) &tag, 4);
		switch(i.p->type)
		{
		case FXSSLPKey::RSA:
			{
				if(!i.p->key.rsa)
				{
					if(!(i.p->key.rsa=RSA_new())) FXERRHSSL(-1);
				}
				if(*(FXuint *)"PUB1"==tag)
				{
					s >> len; s.readRawBytes(buffer, FXMIN(len, 1024));
					if(!(i.p->key.rsa->n=BN_bin2bn(buffer, len, NULL))) FXERRHSSL(-1);
					s >> len; s.readRawBytes(buffer, FXMIN(len, 1024));
					if(!(i.p->key.rsa->e=BN_bin2bn(buffer, len, NULL))) FXERRHSSL(-1);
				}
				else if(*(FXuint *)"PRV1"==tag)
				{
					s >> len; s.readRawBytes(buffer, FXMIN(len, 1024));
					if(!(i.p->key.rsa->d=BN_bin2bn(buffer, len, NULL))) FXERRHSSL(-1);
				}
				else if(*(FXuint *)"ENDK"==tag) break;
				else FXERRG(QTrans::tr("FXSSLPKey", "Unknown tag"), FXSSLPKEY_BADFORMAT, 0);
				break;
			}
		}
	} while(*(FXuint *)"ENDK"!=tag);
#endif
	return s;
}




class FXSSLKeyPrivate
{
public:
	FXuint bitsize;		// Bits in the key
	FXuint size;		// Bytes holding the key (not the same when encrypted)
	FXSSLKey::KeyType type;
	FXuint saltlen;
	void *key;
	FXSSLPKey *pkey;
	FXSSLKeyPrivate(FXuint _bitsize, FXSSLKey::KeyType _type)
		: bitsize(_bitsize), size((7+_bitsize)/8), type(_type), saltlen(0), key(0), pkey(0) { }
	~FXSSLKeyPrivate()
	{
		FXDELETE(pkey);
	}
	void setToEncrypted() throw()
	{
		bitsize=0xffffffff;
		type=FXSSLKey::Encrypted;
	}
	FXSSLKeyPrivate &operator=(const FXSSLKeyPrivate &o)
	{
		bitsize=o.bitsize;
		size=o.size;
		type=o.type;
		saltlen=o.saltlen;
		if(o.key)
		{
			FXERRHM(key=Secure::malloc<FXuchar>(size));
			memcpy(key, o.key, size); 
		}
		if(o.pkey)
		{
			FXERRHM(pkey=new FXSSLPKey(*o.pkey));
		}
		return *this;
	}
	void clear()
	{
		if(key) Secure::free(key);
		key=0;
		// Leave pkey alone
	}
	void verifyBitsize()
	{
		FXERRH((bitsize & 63)==0, QTrans::tr("FXSSLKey", "Key length must be a multiple of sixty-four"), FXSSLKEY_BADKEYLEN, 0);
		if(FXSSLKey::Blowfish==type)
            FXERRH(bitsize>=64 && bitsize<=448, QTrans::tr("FXSSLKey", "Blowfish needs a key between 64 and 448 bits"), FXSSLKEY_BADKEYLEN, 0);
		if(FXSSLKey::AES==type)
			FXERRH(128==bitsize || 192==bitsize || 256==bitsize, QTrans::tr("FXSSLKey", "AES needs a key of either 128, 192 or 256 bits"), FXSSLKEY_BADKEYLEN, 0);
	}
	void int_setKey(void *data, FXuint _size)
	{
		if(key) Secure::free(key);
		size=_size;
		FXERRHM(key=Secure::malloc<FXuchar>(size));
		if(data) memcpy(key, data, size);
	}
	void *operator new(size_t size)
	{
		return ::operator new(size, Secure::heap());
	}
	void operator delete(void *p) throw()
	{
		::operator delete(p, Secure::heap());
	}
};

FXSSLKey::FXSSLKey(FXuint bitsize, FXSSLKey::KeyType type, const FXString &text) : p(0)
{
	FXRBOp unconstr=FXRBConstruct(this);
	FXERRHM(p=new FXSSLKeyPrivate(bitsize, type));
	if(!text.empty())
		generateFromText(text);
	else
		generate();
	unconstr.dismiss();
}

FXSSLKey::~FXSSLKey()
{ FXEXCEPTIONDESTRUCT1 {
	if(p)
	{
		p->clear();
		FXDELETE(p);
	}
} FXEXCEPTIONDESTRUCT2; }

FXSSLKey::FXSSLKey(const FXSSLKey &o) : p(0)
{
	FXERRHM(p=new FXSSLKeyPrivate(o.p->bitsize, o.p->type));
	*p=*o.p;
}

FXSSLKey &FXSSLKey::operator=(const FXSSLKey &o)
{
	p->clear();
	*p=*o.p;
	return *this;
}

bool FXSSLKey::operator==(const FXSSLKey &o) const
{
	if(p->bitsize==o.p->bitsize && p->size==o.p->size && p->type==o.p->type)
	{
		if(!p->key && !o.p->key) return true;
		if(p->key && o.p->key) return !memcmp(p->key, o.p->key, p->size);
	}
	return false;
}
bool FXSSLKey::operator<(const FXSSLKey &o) const
{
	if(p->bitsize<o.p->bitsize || p->size<o.p->size || p->type<o.p->type) return true;
	if(!p->key && o.p->key) return true;
	if(p->key && !o.p->key) return false;
	return memcmp(p->key, o.p->key, p->size)<0;
}

FXSSLKey::KeyType FXSSLKey::type() const throw()
{
	return p->type;
}

void FXSSLKey::setType(FXSSLKey::KeyType type)
{
	if(type!=p->type) p->clear();
	p->type=type;
}

FXString FXSSLKey::typeAsString() const
{
	switch(p->type)
	{
	case NoEncryption:
		return FXString("None");
	case Blowfish:
		return FXString("Blowfish");
	case AES:
		return FXString("AES");
	}
	return FXString();
}

FXuint FXSSLKey::saltLen() const throw()
{
	return p->saltlen;
}

void FXSSLKey::setSaltLen(FXuint saltlen)
{
	FXERRH(0==(saltlen & 7), QTrans::tr("FXSSLKey", "Salt length must be a multiple of eight"), FXSSLKEY_BADSALTLEN, 0);
	FXERRH(saltlen<=64, QTrans::tr("FXSSLKey", "Salt length must be less than or equal to 64"), FXSSLKEY_BADSALTLEN, 0);
	p->saltlen=saltlen;
}

FXSSLPKey *FXSSLKey::asymmetricKey() const throw()
{
	return p->pkey;
}

FXSSLKey &FXSSLKey::setAsymmetricKey(const FXSSLPKey *pkey)
{
	if(!pkey)
	{
		FXDELETE(p->pkey);
		return *this;
	}
	if(!p->pkey)
	{
		FXERRHM(p->pkey=new FXSSLPKey(*pkey));
	}
	else
		*p->pkey=*pkey;
	return *this;
}

FXuint FXSSLKey::bytesLen() const throw()
{
	return p->size;
}

FXuint FXSSLKey::bitsLen() const throw()
{
	return p->bitsize;
}

void FXSSLKey::setBitsLen(FXuint newsize)
{
	if(newsize!=p->bitsize)
	{
		p->clear();
		p->bitsize=newsize;
		p->size=(7+newsize)/8;
	}
}

void FXSSLKey::generate()
{
#ifdef HAVE_OPENSSL
	{
		FXuchar buffer[SEED_SIZE];
		FXuval randsize=Secure::Randomness::readBlock(buffer, FXMIN(p->size, Secure::Randomness::size()));
		RAND_seed(buffer, (FXuint) randsize);
	}
	if(NoEncryption!=p->type)
	{
		p->verifyBitsize();
		if(p->key) Secure::free(p->key);
		FXERRHM(p->key=Secure::malloc<FXuchar>(p->size));
		FXERRHSSL(RAND_bytes((unsigned char *) p->key, p->size));
	}
#endif
}

void FXSSLKey::generateFromText(const FXString &text, int rounds)
{
	if(NoEncryption==p->type) return;
#ifdef HAVE_OPENSSL
	p->verifyBitsize();
	if(p->key) Secure::free(p->key);
	FXERRHM(p->key=Secure::malloc<FXuchar>(p->size));

	FXuchar temp[EVP_MAX_KEY_LENGTH];
	FXuchar *key=(FXuchar *) p->key, *textdata=(FXuchar *) text.text();
	FXuint textlength=text.length();
	for(int n=0; n<rounds; n++)
	{
		Secure::TigerHashValue hash1=Secure::TigerHash().calc(textdata, textlength);
		memcpy(key, hash1.data.bytes, FXMIN(24, p->size));		// 192 bits
		if(p->bitsize>192)
		{	// Now SHA-1
			unsigned char hash2[20];
			SHA1(textdata, textlength, hash2);					// 160 bits
			memcpy(key+24, hash2, FXMIN(20, p->size-24));
		}
		if(p->bitsize>352)	// 192+160
		{	// Now MD5
			unsigned char hash3[16];
			MD5(textdata, textlength, hash3);					// 128 bits
			memcpy(key+44, hash3, FXMIN(16, p->size-44));
		}
		if(p->bitsize>480)	// 192+160+128
		{	// Now what?
			FXERRG(QTrans::tr("FXSSLKey", "Keys no bigger than 480 bits can be generated from plaintext"), FXSSLKEY_BADKEYLEN, 0);
		}
		memcpy(temp, key, p->size);
		textdata=temp; textlength=p->size;
	}
	p->saltlen=16;
#endif
}

Secure::TigerHashValue FXSSLKey::hash() const throw()
{
	return Secure::TigerHash().calc((FXuchar *) p->key, p->size);
}


FXStream &operator<<(FXStream &s, const FXSSLKey &i)
{
	s << (FXushort) i.p->type << i.p->size;
	if(FXSSLKey::Encrypted!=i.p->type)
	{
		s << i.p->bitsize << i.p->saltlen;
		i.p->verifyBitsize();
	}
	s.writeRawBytes((FXuchar *) i.p->key, i.p->size);
	return s;
}

FXStream &operator>>(FXStream &s, FXSSLKey &i)
{
	i.p->clear();
	FXushort type;
	FXuint size;
	s >> type;
	s >> size;
	i.p->type=(FXSSLKey::KeyType) type;
	i.p->int_setKey(0, size);
	if(FXSSLKey::Encrypted!=i.p->type)
	{
		s >> i.p->bitsize >> i.p->saltlen;
	}
	else { i.p->bitsize=0xffffffff; i.p->saltlen=0xffffffff; }
	s.readRawBytes((FXuchar *) i.p->key, size);
	return s;
}





struct FXDLLLOCAL QSSLDevicePrivate : public QMutex
{
	QIODevice *dev;
	bool amServer, authenticated;
	volatile bool connected;
	struct enabled_t
	{
		bool v2,v3;
	} enabled;
	FXString ciphers;
	FXSSLKey key;
#ifdef HAVE_OPENSSL
	QMutex negotiationlock, readlock, writelock;
	SSL *handle;
	BIO *bio;
	X509 *peercert;
	EVP_CIPHER_CTX estream;
	FXfval headerdiff;		// The diff between source dev and us due to the TNFXSECD header
	FXuchar *nonce;			// Holds the nonce
	FXuval noncelen;
	FXuchar *ebuffer;		// Holds a block of encryption stream
	FXfval ebufferIoIndex;
#endif
	QSSLDevicePrivate(QIODevice *ed) : dev(ed), amServer(false), connected(false),
		ciphers("HIGH:@STRENGTH"), key(0),
#ifdef HAVE_OPENSSL
		handle(0), bio(0), peercert(0), headerdiff(0), nonce(0), noncelen(0), ebuffer(0), ebufferIoIndex((FXfval)-1),
#endif
		QMutex() { }
	~QSSLDevicePrivate()
	{
#ifdef HAVE_OPENSSL
		if(nonce)
		{
			Secure::free(nonce);
			nonce=0; noncelen=0;
		}
		if(ebuffer)
		{
			Secure::free(ebuffer);
			ebuffer=0;
		}
#endif
	}
#ifdef HAVE_OPENSSL
	void setupSSL()
	{
		{
			FXuchar buffer[SEED_SIZE];
			FXuval size=Secure::Randomness::readBlock(buffer, FXMIN(SEED_SIZE, Secure::Randomness::size()));
			RAND_seed(buffer, (FXuint) size);
		}
		if(!(handle=SSL_new(myinit->ctx))) FXERRHSSL(-1);
		if(enabled.v2 && enabled.v3)
		{
			FXERRHSSL(SSL_set_ssl_method(handle, SSLv23_method()));
		}
		else if(enabled.v2)
		{
			FXERRHSSL(SSL_set_ssl_method(handle, SSLv2_method()));
		}
		else
		{
			FXERRHSSL(SSL_set_ssl_method(handle, SSLv3_method()));
		}
		FXERRHSSL(SSL_set_cipher_list(handle, ciphers.text()));
		if(!(bio=BIO_new(&BIO_s_QIODevice))) FXERRHSSL(-1);
		BIO_set_fp(bio, dev, 0);
		SSL_set_bio(handle, bio, bio);
	}
	void negotiate()
	{	// Negotiation is not threadsafe, even at the device level :(
		bool oldConnected=connected;
		QMtxHold h2(negotiationlock);
		if(!oldConnected && connected) return;

		QMtxHold h(this);
		if(connected)
		{
			if(amServer)
			{	// Need to temporarily disable the session cache
				FXString myname("TnFOX_%1_%2_%3_disabled");
				myname.arg(FXNetwork::hostname()).arg(FXPath::name(FXProcess::execpath())).arg(FXProcess::id(), 0, 16);
				FXERRHSSL(SSL_CTX_set_session_id_context(myinit->ctx, (unsigned char *) myname.text(), myname.length()));
			}
			int ret;
			h.unlock();
			ret=SSL_renegotiate(handle);
			if(ret>0) ret=SSL_do_handshake(handle);
			if(ret>0 && amServer) 
			{	// Need to force client to renegotiate and if not, kill connection
				handle->state=SSL_ST_ACCEPT;
				ret=SSL_do_handshake(handle);
			}
			h.relock();
			if(amServer)
			{
				FXString myname("TnFOX_%1_%2_%3");
				myname.arg(FXNetwork::hostname()).arg(FXPath::name(FXProcess::execpath())).arg(FXProcess::id(), 0, 16);
				FXERRHSSL(SSL_CTX_set_session_id_context(myinit->ctx, (unsigned char *) myname.text(), myname.length()));
			}
			FXERRHSSL(ret);
		}
		else
		{
			if(amServer)
			{
				h.unlock();
				int ret=SSL_accept(handle);
				h.relock();
				if(!ret)	// negotiation failed
				{
					FXERRG(getSSLError(), QSSLDEVICE_NEGOTIATIONFAILED, 0);
				}
				FXERRHSSL(ret);
			}
			else
			{
				h.unlock();
				int ret=SSL_connect(handle);
				h.relock();
				if(!ret)	// negotiation failed
				{
					FXERRG(getSSLError(), QSSLDEVICE_NEGOTIATIONFAILED, 0);
				}
				FXERRHSSL(ret);
			}
		}
		connected=true;
		if(SSL_get_verify_result(handle)==X509_V_OK)
		{
			peercert=SSL_get_peer_certificate(handle);
		}
	}
#endif
};

void *QSSLDevice::int_getOSHandle() const
{
	return p->dev->isSynchronous() ? static_cast<QIODeviceS *>(p->dev)->int_getOSHandle() : 0;
}
#ifdef HAVE_OPENSSL
inline void QSSLDevice::int_genEBuffer() const
{
	FXfval cblock=ioIndex-(ioIndex % p->noncelen);
	if(p->ebufferIoIndex!=cblock)
	{	// XOR the nonce and ioIndex and encrypt to generate ebuffer
		FXuchar *buffer=(FXuchar *) alloca(p->noncelen+4);	// use alloca() for speed
		if((((FXuval) buffer) & 4)) buffer+=4;	// align
		assert(p->noncelen>=8);
		// Keysize is guaranteed to be multiple of 8
		FXSTATIC_ASSERT(sizeof(FXfval)==8, FXfval_Is_Not_Eight);
		for(FXuval n=0; n<p->noncelen/sizeof(FXfval); n++)
			((FXfval *) buffer)[n]=((FXfval *) p->nonce)[n] ^ (cblock+n*sizeof(FXfval));
		int outlen=0, ret;
		ret=EVP_EncryptUpdate(&p->estream, p->ebuffer, &outlen, buffer, (FXuint) p->noncelen);
		memset(buffer, 0, p->noncelen);		// Ensure buffer is wiped on exit
		FXERRHSSL(ret);
		assert(outlen==p->noncelen);
		p->ebufferIoIndex=cblock;
	}
}

void QSSLDevice::int_xorInEBuffer(char *dest, const char *src, FXuval amount)
{	// Keysize must be a multiple of 8, so we can process in 64 bit words for speed
	FXSTATIC_ASSERT(sizeof(FXulong)==8, FXulong_Is_Not_Eight);
	bool first=true;
	// Try to optimise by address alignment
	while(amount)
	{
		FXival ebufferoffset=(FXival)(ioIndex % p->noncelen);
		FXuchar *ebuffer=FXOFFSETPTR(p->ebuffer, ebufferoffset);
		if(first || !ebufferoffset)
		{	// Only call this when needed
			int_genEBuffer();
			first=false;
		}
		FXuval d=(FXuval) dest, s=(FXuval) src, e=(FXuval) ebuffer, todo=FXMIN(amount, p->noncelen-ebufferoffset), size=0;
#if 0
		if(todo>=16 && !(d & 15) && !(s & 15) && !(e & 15))
		{	// TODO: Use SSE2 16 byte XOR
			int a=1;
		}
#endif
		if(todo>=8 && !(d & 7) && !(s & 7) && !(e & 7))
		{	// Do it as one 64 bit op
			*((FXulong *) dest)=*((FXulong *) src) ^ *((FXulong *) ebuffer);
			size=8;
			goto end;
		}
		if(todo>=4 && !(d & 3) && !(s & 3) && !(e & 3))
		{	// Do it as one 32 bit op
			*((FXuint *) dest)=*((FXuint *) src) ^ *((FXuint *) ebuffer);
			size=4;
			goto end;
		}
		if(todo>=2 && !(d & 1) && !(s & 1) && !(e & 1))
		{	// Do it as one 16 bit op
			*((FXushort *) dest)=*((FXushort *) src) ^ *((FXushort *) ebuffer);
			size=2;
			goto end;
		}
		*((FXuchar *) dest)=*((FXuchar *) src) ^ *((FXuchar *) ebuffer);
		size=1;
end:
		dest+=size; src+=size; ioIndex+=size; amount-=size;
	}
}
#endif

QSSLDevice::QSSLDevice(QIODevice *encrypteddev, bool enablev2) : p(0), QIODeviceS()
{
#ifndef HAVE_OPENSSL
	FXERRH(false, QTrans::tr("QSSLDevice", "OpenSSL support not enabled"), QSSLDEVICE_NOTENABLED, 0);
#endif
	FXRBOp unconstruct=FXRBConstruct(this);
	FXERRHM(p=new QSSLDevicePrivate(encrypteddev));
	myinit->setup();
	p->enabled.v2=enablev2;
	p->enabled.v3=true;
	unconstruct.dismiss();
}

QSSLDevice::~QSSLDevice()
{ FXEXCEPTIONDESTRUCT1 {
	close();
	FXDELETE(p);
} FXEXCEPTIONDESTRUCT2; }

QIODevice *QSSLDevice::encryptedDev() const throw()
{
	QMtxHold h(p);
	return p->dev;
}

void QSSLDevice::setEncryptedDev(QIODevice *dev)
{
	QMtxHold h(p);
	close();
	p->dev=dev;
}

const FXSSLKey &QSSLDevice::key() const
{
	QMtxHold h(p);
	return p->key;
}

void QSSLDevice::setKey(const FXSSLKey &key)
{
	QMtxHold h(p);
	p->key=key;
}

bool QSSLDevice::SSLv2Available() const throw()
{
	QMtxHold h(p);
	return p->enabled.v2;
}
void QSSLDevice::setSSLv2Available(bool a)
{
	QMtxHold h(p);
	p->enabled.v2=a;
}
bool QSSLDevice::SSLv3Available() const throw()
{
	QMtxHold h(p);
	return p->enabled.v3;
}
void QSSLDevice::setSSLv3Available(bool a)
{
	QMtxHold h(p);
	p->enabled.v3=a;
}
FXString QSSLDevice::ciphers() const
{
	QMtxHold h(p);
	FXString ret;
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		FXERRH(p->dev->isSynchronous(), QTrans::tr("QSSLDevice", "File type devices not supported"), QSSLDEVICE_FILENOTSUPP, 0);
		const char *cipherlist=0;
		int n=0;
		do
		{
			if((cipherlist=SSL_get_cipher_list(p->handle, n++)))
				ret+=FXString(cipherlist)+':';
		} while(cipherlist);
		if(!ret.empty()) ret.truncate(ret.length()-1);
	}
	else ret=p->ciphers;
#endif
	return ret;
}
void QSSLDevice::setCiphers(const FXString &list)
{
	QMtxHold h(p);
	p->ciphers=list;
}



bool QSSLDevice::usingSSLv2() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	return 0==strcmp("SSLv2", SSL_get_cipher_version(p->handle));
#else
	return false;
#endif
}
bool QSSLDevice::usingSSLv3() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	return 0==strcmp("SSLv3", SSL_get_cipher_version(p->handle));
#else
	return false;
#endif
}
bool QSSLDevice::usingTLSv1() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	return 0==strcmp("TLSv1", SSL_get_cipher_version(p->handle));
#else
	return false;
#endif
}
FXString QSSLDevice::peerHostNameByCertificate() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	if(p->peercert)
	{
		char peername[256];
		X509_NAME_get_text_by_NID(X509_get_subject_name(p->peercert), NID_commonName,
			peername, sizeof(peername));
		return FXString(peername);
	}
#endif
	return FXString();
}
FXString QSSLDevice::cipherName() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	if(p->dev->isSynchronous())
		return FXString(SSL_get_cipher_name(p->handle));
	else
		return p->key.typeAsString();
#else
	return FXString();
#endif
}
FXuint QSSLDevice::cipherBits() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	if(p->dev->isSynchronous())
		return SSL_get_cipher_bits(p->handle, 0);
	else
		return p->key.bitsLen();
#else
	return 0;
#endif
}
FXString QSSLDevice::cipherDescription() const
{
	QMtxHold h(p);
#ifdef HAVE_OPENSSL
	if(p->dev->isSynchronous())
	{
		char buffer[256];
		return FXString(SSL_CIPHER_description(SSL_get_current_cipher(p->handle), buffer, sizeof(buffer)));
	}
	else
		return FXString("%1(%2)").arg(p->key.typeAsString()).arg(p->key.bitsLen());
#else
	return FXString();
#endif
}

void QSSLDevice::renegotiate()
{	// Don't hold the mutex
#ifdef HAVE_OPENSSL
	p->negotiate();
#endif
}

FXuint QSSLDevice::fileHeaderLen() const throw()
{
#ifdef HAVE_OPENSSL
	return (FXuint) p->headerdiff;
#else
	return 0;
#endif
}

bool QSSLDevice::isSynchronous() const
{
	if(p->dev) return p->dev->isSynchronous();
	return false;
}
bool QSSLDevice::create(FXuint mode)
{
#ifdef HAVE_OPENSSL
	FXERRH(p->dev->isSynchronous(), QTrans::tr("QSSLDevice", "File type devices not supported"), QSSLDEVICE_FILENOTSUPP, 0);
	QMtxHold h(p);
	close();
	QIODeviceS *sdev=(QIODeviceS *) p->dev;
	if(sdev->isClosed()) sdev->create(IO_ReadWrite);
	p->setupSSL();
	p->amServer=true;
	p->connected=false;
	setFlags((mode & IO_ModeMask)|IO_Open);
#endif
	return true;
}

#define readLE2(val, ptr) { val|=(ptr)[0]; val|=((ptr)[1])<<8; }
#define writeLE2(ptr, val) { (ptr)[0]=(FXuchar)(((val)>>0) & 0xff); (ptr)[1]=(FXuchar)(((val)>>8) & 0xff); }
#define readLE4(val, ptr) { readLE2(val, (ptr)+2); val<<=16; readLE2(val, ptr); }
#define writeLE4(ptr, val) { writeLE2(ptr, val); writeLE2((ptr)+2, val>>16); }
bool QSSLDevice::open(FXuint mode)
{
#ifdef HAVE_OPENSSL
	if(isOpen())
	{	// I keep fouling myself up here, so assertion check
		if(QIODevice::mode()!=mode) FXERRGIO(QTrans::tr("QSSLDevice", "Device reopen has different mode"));
	}
	else
	{
		FXERRH(mode & IO_ReadWrite, "You must specify at least one of IO_ReadOnly or IO_WriteOnly!", 0, FXERRH_ISDEBUG);
		QMtxHold h(p);
		if(p->dev->isSynchronous())
		{
			p->dev->open(IO_ReadWrite);
			p->setupSSL();
		}
		else
		{
			FXSSLPKey *pkey=p->key.asymmetricKey();
			FXuchar version=0;
			if(pkey)
			{
				if(mode & IO_ReadOnly)
				{
					FXERRH(pkey->hasPrivateKey(), QTrans::tr("QSSLDevice", "Need private key to decrypt"), QSSLDEVICE_NEEDPRIVATEKEY, 0);
				}
				if(mode & IO_WriteOnly)
				{
					FXERRH(pkey->hasPublicKey(), QTrans::tr("QSSLDevice", "Need public key to encrypt"), QSSLDEVICE_NEEDPUBLICKEY, 0);
					FXERRH((mode & IO_ReadOnly) || !(pkey->hasPublicKey() && pkey->hasPrivateKey()), "Security check: asymmetric encryption with both public & private keys", 0, FXERRH_ISDEBUG);
				}
			}
			FXRBOp undevopen=FXRBObj(*p->dev, p->dev->isOpen() ? 0 : &QIODevice::close);
			p->dev->open(mode);
			FXStream s(p->dev);
			FXSSLKey key=p->key;
			if(p->dev->isReadable() && !p->dev->atEnd())
			{	// Read the header
				FXulong header;
				s.readRawBytes((char *) &header, 8); s >> version;
				FXERRH(header==*((FXulong *)"TNFXSECD"), QTrans::tr("QSSLDevice", "Not a TnFOX secure data file"), QSSLDEVICE_BADFORMAT, 0);
				FXERRH(2==version, QTrans::tr("QSSLDevice", "Secure file format too new"), QSSLDEVICE_BADFORMAT, 0);
				if(pkey)
				{	// Read header for key
					int ret;
					FXuint keytag=0;
					s.readRawBytes((char *) &keytag, 4);
					FXERRH(keytag==*((FXuint *)"SKEY"), QTrans::tr("QSSLDevice", "Secure file missing symmetric key"), QSSLDEVICE_MISSINGKEY, 0);
					s >> key;
					FXuchar *buffer;
					FXERRHM(buffer=Secure::malloc<FXuchar>(SEED_SIZE));
					FXRBOp unbuffer=FXRBFunc(&Secure::free<FXuchar>, buffer);
					FXERRH(key.bytesLen()<=SEED_SIZE, "SEED_SIZE exceeded", 0, FXERRH_ISDEBUG);
					if(-1==(ret=RSA_private_decrypt(key.bytesLen(), (FXuchar *) key.p->key, buffer,
						pkey->p->key.rsa, RSA_PKCS1_PADDING)))
					{
						FXERRG(QTrans::tr("QSSLDevice", "Incorrect key"), QSSLDEVICE_INCORRECTKEY, 0);
					}
					ret-=2*sizeof(FXuint)+sizeof(FXushort);
					FXuint bitsize=0, saltlen=0; FXushort type=0;
					readLE4(bitsize, buffer+ret);
					readLE4(saltlen, buffer+ret+sizeof(FXuint));
					readLE2(type, buffer+ret+2*sizeof(FXuint));
					key.p->bitsize=bitsize;
					key.p->saltlen=saltlen;
					key.p->type=(FXSSLKey::KeyType) type;
					key.p->int_setKey(buffer, ret);
					p->key=key;
				}
				FXuint testtag;
				s.readRawBytes((char *) &testtag, 4);
				FXERRH(testtag==*((FXuint *)"TEST"), QTrans::tr("QSSLDevice", "Missing key test hash"), QSSLDEVICE_BADFORMAT, 0);
				Secure::TigerHashValue testkeyhash;
				s.readRawBytes(testkeyhash.data.bytes, sizeof(testkeyhash));
				FXulong keysalt=0, keysaltlen=(1<<key.saltLen())-1; bool gotIt=false;
				FXuchar *hashbuffer, *endp;
				FXERRHM(hashbuffer=Secure::malloc<FXuchar>(EVP_MAX_KEY_LENGTH));
				FXRBOp unhashbuffer=FXRBFunc(&Secure::free<FXuchar>, hashbuffer);
				FXuint keylen=key.bytesLen();
				memcpy(hashbuffer, key.p->key, keylen);
				endp=hashbuffer+keylen;
#ifdef DEBUG
				fxmessage("keytop=%x\n", *(FXuint *)(hashbuffer));
#endif
				do
				{
					FXuint n;
					for(n=0; n<key.saltLen(); n+=8)
					{
						hashbuffer[n/8]^=(FXuchar)((keysalt>>n) & 0xff);
					}
					FXuint hashsalt;
					for(hashsalt=(!key.saltLen()) ? 0 : 65535; hashsalt<65536; hashsalt++)
					{
						*(FXushort *)(endp)=(FXushort) hashsalt;
						Secure::TigerHashValue keyhash=Secure::TigerHash().calc(hashbuffer, keylen+(!key.saltLen() ? 2 : 0));
						if(keyhash==testkeyhash)
						{
							gotIt=true;
							break;
						}
					}
					if(gotIt)
					{
#ifdef DEBUG
						fxmessage("Found with keysalt=%x and hashsalt=%x, keytop=%x\n", (FXuint) keysalt, hashsalt, *(FXuint *)(hashbuffer));
#endif
						hashsalt=0;
						break;
					}
					for(n=0; n<key.saltLen(); n+=8)
					{
						hashbuffer[n/8]^=(FXuchar)((keysalt>>n) & 0xff);
					}
				} while(keysalt++<=keysaltlen);
				FXERRH(gotIt, QTrans::tr("QSSLDevice", "Incorrect key"), QSSLDEVICE_INCORRECTKEY, 0);
				keysalt=0;
				memcpy(key.p->key, hashbuffer, keylen);
			}
			else if(p->dev->isWriteable())
			{	// Write header
				s.writeRawBytes("TNFXSECD", 8);
				version=2;
				s << version;
				if(pkey)
				{	// Write header for key
					int ret;
					s.writeRawBytes("SKEY", 4);
					FXuchar *buffer, *source;
					FXERRHM(buffer=Secure::malloc<FXuchar>(SEED_SIZE));
					FXRBOp unbuffer=FXRBFunc(&Secure::free<FXuchar>, buffer);
					FXERRHM(source=Secure::malloc<FXuchar>(SEED_SIZE));
					FXRBOp unsource=FXRBFunc(&Secure::free<FXuchar>, source);
					FXERRH(key.bytesLen()+6<=SEED_SIZE, "SEED_SIZE exceeded", 0, FXERRH_ISDEBUG);
					memcpy(source, key.p->key, key.bytesLen());
					writeLE4(source+key.bytesLen(), key.bitsLen());
					writeLE4(source+key.bytesLen()+sizeof(FXuint), key.saltLen());
					writeLE2(source+key.bytesLen()+2*sizeof(FXuint), key.type());
					if(!(ret=RSA_public_encrypt(key.bytesLen()+2*sizeof(FXuint)+sizeof(FXushort),
						source, buffer, pkey->p->key.rsa, RSA_PKCS1_PADDING))) FXERRHSSL(-1);
					FXSSLKey tempkey(0);
					tempkey.p->setToEncrypted();
					tempkey.p->int_setKey((void *) buffer, ret);
					s << tempkey;
				}
				if(key.saltLen())
				{	// EOR in some saltiness
					FXERRH(key.saltLen()<key.bitsLen(), QTrans::tr("QSSLDevice", "Key salt length must be smaller or equal to key length"), FXSSLKEY_BADSALTLEN, 0);
					FXulong saltdata=0;
					FXuchar *salt=(FXuchar *) &saltdata, *keydata=(FXuchar *) key.p->key;
					FXuint saltlen=(7+key.saltLen())/8;
					FXERRHSSL(RAND_bytes(salt, saltlen));
					for(FXuint n=0; n<saltlen; n++)
					{
						keydata[n]^=salt[n];
					}
#ifdef DEBUG
					fxmessage("Used keysalt=%x, keytop=%x\n", (FXuint) saltdata, *(FXuint *)(keydata));
#endif
					saltdata=0;
				}
				s.writeRawBytes("TEST", 4);
				FXuchar *hashbuffer;
				FXERRHM(hashbuffer=Secure::malloc<FXuchar>(EVP_MAX_KEY_LENGTH+2));
				FXRBOp unhashbuffer=FXRBFunc(&Secure::free<FXuchar>, hashbuffer);
				FXuint keylen=key.bytesLen();
				memcpy(hashbuffer, key.p->key, keylen);
				if(!key.saltLen())
				{
					FXERRHSSL(RAND_bytes(hashbuffer+keylen, 2));		// 16 bits of salt
				}
				else *(FXushort *)(hashbuffer+keylen)=0xffff;
#ifdef DEBUG
				fxmessage("Used hashsalt=%x\n", (FXuint)(*(FXushort *)(hashbuffer+keylen)));
#endif
				Secure::TigerHashValue keyhash=Secure::TigerHash().calc(hashbuffer, keylen+(!key.saltLen() ? 2 : 0));
				s.writeRawBytes(keyhash.data.bytes, sizeof(keyhash));
			}
			p->headerdiff=p->dev->at();

			// Okay set up for reading & writing
			assert(!p->nonce);
			assert(!p->ebuffer);
			const EVP_CIPHER *cipher=0;
			switch(key.type())
			{
			case FXSSLKey::NoEncryption:
				cipher=EVP_enc_null();
				break;
			case FXSSLKey::Blowfish:
				cipher=EVP_bf_ecb();
				break;
			case FXSSLKey::AES:
				{
					switch(key.bitsLen())
					{
					case 128:
						cipher=EVP_aes_128_ecb();
						break;
					case 192:
						cipher=EVP_aes_192_ecb();
						break;
					case 256:
						cipher=EVP_aes_256_ecb();
						break;
					default:
						{ assert(0); }
					}
					break;
				}
			default:
				FXERRG(QTrans::tr("QSSLDevice", "Key of unknown encryption type"), QSSLDEVICE_UNKNOWNENCRYPTION, 0);
			}
			// Initialise the cipher
			EVP_CIPHER_CTX_init(&p->estream);
			FXERRHSSL(EVP_EncryptInit_ex(&p->estream, cipher, NULL, (FXuchar *) key.p->key, NULL));
			if(FXSSLKey::Blowfish==key.type())
				FXERRHSSL(EVP_CIPHER_CTX_set_key_length(&p->estream, key.bitsLen()));
			p->noncelen=EVP_CIPHER_CTX_block_size(&p->estream);
			if(p->noncelen<8) p->noncelen=8;	// For null cipher
			p->headerdiff+=p->noncelen;
			// Allocate nonce and buffers
			FXERRHM(p->nonce=Secure::malloc<FXuchar>(p->noncelen));
			FXERRHM(p->ebuffer=Secure::malloc<FXuchar>(p->noncelen));
			p->ebufferIoIndex=(FXfval)-1;

			if((mode & IO_ReadOnly) && !p->dev->atEnd())
			{	// Read in the nonce
				s.readRawBytes(p->nonce, p->noncelen);
#ifdef DEBUG
				fxmessage("QSSLDevice: Reading nonce=%s\n", fxdump8(p->nonce, p->noncelen).text());
#endif
			}
			else
			{	// Generate and write the nonce
				//if(EVP_enc_null()!=cipher)
					FXERRHSSL(RAND_pseudo_bytes(p->nonce, (FXuint) p->noncelen));
				s.writeRawBytes(p->nonce, p->noncelen);
#ifdef DEBUG
				fxmessage("QSSLDevice: Writing nonce=%s\n", fxdump8(p->nonce, p->noncelen).text());
#endif
			}
			ioIndex=0;
			undevopen.dismiss();
		}
		p->amServer=false;
		p->connected=false;
		setFlags((mode & IO_ModeMask)|IO_Open);
	}
#endif
	return true;
}

void QSSLDevice::close()
{
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		QMtxHold h(p);
		if(!p->dev->isSynchronous())
		{
			int bufflen=0;
			// Throw away remainder
			FXERRHSSL(EVP_EncryptFinal_ex(&p->estream, p->ebuffer, &bufflen));
			FXERRHSSL(EVP_CIPHER_CTX_cleanup(&p->estream));
			Secure::free(p->nonce);
			p->nonce=0; p->noncelen=0;
			Secure::free(p->ebuffer);
			p->ebuffer=0;
		}
		if(p->peercert)
		{
			X509_free(p->peercert);
			p->peercert=0;
		}
		if(p->handle)
		{
			h.unlock();
			int ret=SSL_shutdown(p->handle);
			if(0==ret) ret=SSL_shutdown(p->handle);
			if(-1==ret) FXERRHSSL(ret);
			h.relock();
			SSL_free(p->handle);
			ERR_clear_error();
			p->handle=0;
			p->bio=0;
		}
		if(p->dev)
		{
			p->dev->close();
		}
		ioIndex=0;
		p->connected=false;
		setFlags(0);
	}
#endif
}

void QSSLDevice::flush()
{
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		QMtxHold h(p);
		if(p->dev->isSynchronous())
			BIO_flush(p->bio);	// Probably a null op but do it anyway
		else
		{
			p->dev->flush();
		}
	}
#endif
}

FXfval QSSLDevice::size() const
{
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		QMtxHold h(p);
		if(p->dev->isSynchronous())
            return SSL_pending(p->handle);
		else
			return p->dev->size()-(p->dev->at()-ioIndex);
	}
#endif
	return 0;
}

void QSSLDevice::truncate(FXfval size)
{
#ifdef HAVE_OPENSSL
	if(isOpen() && !p->dev->isSynchronous())
	{
		QMtxHold h(p);
		p->dev->truncate(size+p->headerdiff);
		ioIndex=p->dev->at()-p->headerdiff;
	}
#endif
}

FXfval QSSLDevice::at() const
{
	return ioIndex;
}

bool QSSLDevice::at(FXfval newpos)
{
#ifdef HAVE_OPENSSL
	if(isOpen() && newpos!=ioIndex && !p->dev->isSynchronous())
	{
		QMtxHold h(p);
		p->dev->at(newpos+p->headerdiff);
		ioIndex=newpos;
		return true;
	}
#endif
	return false;
}

bool QSSLDevice::atEnd() const
{
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		if(p->dev->isSynchronous())
			return size()!=0;
		else
			return p->dev->atEnd();
	}
#endif
	return true;
}

const FXACL &QSSLDevice::permissions() const
{
	return p->dev->permissions();
}
void QSSLDevice::setPermissions(const FXACL &perms)
{
	p->dev->setPermissions(perms);
}

FXuval QSSLDevice::readBlock(char *data, FXuval maxlen)
{
	if(!QIODevice::isReadable()) FXERRGIO(QTrans::tr("QSSLDevice", "Not open for reading"));
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		QMtxHold h(p);
		if(p->dev->isSynchronous())
		{
			int ret=0;
			h.unlock();
			if(!p->connected) p->negotiate();
			if(maxlen)
			{
				QMtxHold h2(p->readlock);
				ret=SSL_read(p->handle, (void *) data, (int) maxlen);
				if(ret<0)
					FXERRHSSL(ret);
			}
			return (FXuval) ret;
		}
		else
		{
			FXuval count=maxlen;
			while(count)
			{	// Read same amount of bytes from source
				FXuval read=0;
				h.unlock();
				if(!(read=p->dev->readBlock(data, count))) break;
				h.relock();
				// Now decrypt, block by block
				int_xorInEBuffer(data, data, read);		// advances ioIndex for us
				count-=read;
			}
			return maxlen-count;
		}
	}
#endif
	return 0;
}

FXuval QSSLDevice::writeBlock(const char *data, FXuval maxlen)
{
	if(!QIODevice::isWriteable()) FXERRGIO(QTrans::tr("QSSLDevice", "Not open for writing"));
#ifdef HAVE_OPENSSL
	if(isOpen())
	{
		QMtxHold h(p);
		if(p->dev->isSynchronous())
		{
			int ret=0;
			h.unlock();
			if(!p->connected) p->negotiate();
			if(maxlen)
			{
				QMtxHold h2(p->writelock);
				ret=SSL_write(p->handle, (const void *) data, (int) maxlen);
				if(ret<0)
					FXERRHSSL(ret);
			}
			return (FXuval) ret;
		}
		else
		{
			static const FXuval blockSize=65536;
			FXuval count=maxlen;
			char _buffer[blockSize+4];	// aligns to a 4 byte boundary
			char *buffer=_buffer;
			// Align to data
			if((((FXuval) data) & 4)!=(((FXuval) buffer) & 4)) buffer+=4;
			while(count)
			{	// Encrypt to buffer and write
				FXuval written, towrite=FXMIN(count, blockSize);
				int_xorInEBuffer(buffer, data, towrite);		// advances ioIndex for us
				h.unlock();
				if(!(written=p->dev->writeBlock(buffer, towrite))) break;
				h.relock();
				ioIndex-=towrite-written;
				count-=written;
			}
			return maxlen-count;
		}
	}
#endif
	return 0;
}

FXuval QSSLDevice::readBlockFrom(char *data, FXuval maxlen, FXfval newpos)
{
	if(isOpen())
	{
		QMtxHold h(p);
		if(ioIndex!=newpos)
			QSSLDevice::at(newpos);
		return readBlock(data, maxlen);
	}
	return 0;
}
FXuval QSSLDevice::writeBlockTo(FXfval newpos, const char *data, FXuval maxlen)
{
	if(isOpen())
	{
		QMtxHold h(p);
		if(ioIndex!=newpos)
			QSSLDevice::at(newpos);
		return writeBlock(data, maxlen);
	}
	return 0;
}

int QSSLDevice::ungetch(int c)
{
	return -1;	// not supported
}

void QSSLDevice::setCertificateFile(const FXString &path)
{
#ifdef HAVE_OPENSSL
	myinit->setup();
	FXERRHSSL(SSL_CTX_use_certificate_chain_file(myinit->ctx, path.text()));
	//FXERRHSSL(SSL_CTX_load_verify_locations(myinit->ctx, "root.pem", 0));
	FXERRHSSL(SSL_CTX_check_private_key(myinit->ctx));
#endif
}

#ifdef HAVE_OPENSSL
static FXString PrivateKeyFilePassword;
static int returnPassword(char *buffer, int size, int rwflag, void *userdata)
{
	strcpy(buffer, PrivateKeyFilePassword.text());
	return PrivateKeyFilePassword.length();
}
#endif
void QSSLDevice::setPrivateKeyFile(const FXString &path, const FXString &password)
{
#ifdef HAVE_OPENSSL
	PrivateKeyFilePassword=password;
	myinit->setup();
	SSL_CTX_set_default_passwd_cb(myinit->ctx, (PrivateKeyFilePassword.empty()) ? NULL : returnPassword);
	FXERRHSSL(SSL_CTX_use_PrivateKey_file(myinit->ctx, path.text(), SSL_FILETYPE_PEM));
#endif
}

const FXString &QSSLDevice::strongestAnonCipher()
{
	static FXString temp("ADH-AES256-SHA");
	return temp;
}
const FXString &QSSLDevice::fastestAnonCipher()
{
	static FXString temp("ADH-AES128-SHA");
	return temp;
}

//**********************************************************************************

namespace Secure
{
	FXuval PRandomness::readBlock(FXuchar *buffer, FXuval length)
	{
#ifdef HAVE_OPENSSL
		FXERRHSSL(RAND_bytes(buffer, (FXuint) length));
		return length;
#else
		return 0;
#endif
	}
	void PRandomness::freshen(FXuval amount)
	{
#ifdef HAVE_OPENSSL
		FXuchar buffer[SEED_SIZE];
		if(amount>SEED_SIZE) amount=SEED_SIZE;
		FXuval randsize=Secure::Randomness::readBlock(buffer, FXMIN(amount, Secure::Randomness::size()));
		RAND_seed(buffer, (FXuint) randsize);
#endif
	}
}

} // namespace

