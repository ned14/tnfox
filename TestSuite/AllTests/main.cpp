/********************************************************************************
*                                                                               *
*                               Tests Everything                                *
*                                                                               *
*********************************************************************************
*        Copyright (C) 2007 by Niall Douglas.   All Rights Reserved.            *
*   NOTE THAT I NIALL DOUGLAS DO NOT PERMIT ANY OF MY CODE USED UNDER THE GPL   *
*********************************************************************************
* This code is free software; you can redistribute it and/or modify it under    *
* the terms of the GNU Library General Public License v2.1 as published by the  *
* Free Software Foundation EXCEPT that clause 3 does not apply ie; you may not  *
* "upgrade" this code to the GPL without my prior written permission.           *
* Please consult the file "License_Addendum2.txt" accompanying this file.       *
*                                                                               *
* This code is distributed in the hope that it will be useful,                  *
* but WITHOUT ANY WARRANTY; without even the implied warranty of                *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                          *
*********************************************************************************
* $Id:                                                                          *
********************************************************************************/


#include "fx.h"

/* Generated by reswrap from file RedExclamation.gif */
const unsigned char RedExclamation[]={
  0x47,0x49,0x46,0x38,0x39,0x61,0x12,0x00,0x12,0x00,0x87,0x00,0x00,0x00,0x82,0x84,
  0xd6,0xa2,0xa5,0xc6,0x75,0x73,0xbd,0x55,0x52,0xbd,0x34,0x31,0xbd,0x2c,0x29,0xb5,
  0x28,0x29,0xb5,0x49,0x4a,0xc6,0x34,0x31,0xd6,0x59,0x5a,0xff,0xf7,0xf7,0xad,0x28,
  0x29,0xbd,0x38,0x39,0xce,0x3c,0x39,0xd6,0x3c,0x39,0xde,0x65,0x63,0xd6,0x61,0x63,
  0xce,0x34,0x31,0xde,0x3c,0x39,0xde,0x45,0x42,0xde,0x69,0x6b,0xde,0xa6,0xa5,0xe7,
  0x45,0x42,0xe7,0x4d,0x4a,0xff,0xeb,0xef,0xce,0x7d,0x7b,0xef,0x4d,0x4a,0xef,0x82,
  0x84,0xff,0xff,0xff,0xe7,0x79,0x7b,0xf7,0x4d,0x4a,0xff,0xd3,0xd6,0xf7,0xd7,0xd6,
  0xf7,0x51,0x52,0xff,0x55,0x52,0xff,0xdf,0xde,0xc6,0x5d,0x5a,0xff,0xc7,0xc6,0xf7,
  0xc3,0xc6,0xd6,0x49,0x4a,0xf7,0xb6,0xb5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,
  0x03,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x12,0x00,0x12,0x00,0x00,0x08,
  0xc3,0x00,0x01,0x08,0x1c,0x48,0xb0,0xa0,0x41,0x82,0x15,0x32,0x64,0xa8,0x70,0xb0,
  0x20,0x09,0x09,0x16,0x24,0x48,0x6c,0x30,0xa0,0x21,0x80,0x13,0x17,0x34,0x68,0x40,
  0x81,0x42,0x82,0x83,0x06,0x0c,0x0e,0x4a,0xd0,0xe0,0xc1,0x43,0x09,0x0e,0x1c,0x4c,
  0x38,0x70,0x80,0x80,0x80,0xc3,0x0b,0x25,0x45,0x7c,0x40,0x09,0xc2,0x63,0x04,0x04,
  0x15,0x07,0x8e,0xf4,0x10,0x42,0xc4,0x08,0x9a,0x36,0x5b,0x0e,0xac,0x60,0x01,0x66,
  0xcf,0x9f,0x1c,0x46,0x04,0x2d,0x10,0x40,0x60,0x06,0x88,0x24,0x3d,0xcc,0xe4,0x50,
  0xb3,0xc1,0xcd,0x02,0x02,0x9c,0x3a,0xb0,0x60,0x41,0xe3,0x06,0x94,0x1d,0x3e,0x22,
  0x40,0x60,0x20,0x2b,0x80,0x0a,0x12,0x21,0x16,0xc5,0x80,0x41,0x42,0x83,0x06,0x08,
  0x0a,0x18,0x68,0x2a,0xb0,0x81,0x83,0xb4,0x13,0x28,0x3c,0x10,0x4b,0xc0,0x80,0x01,
  0x82,0x03,0xec,0xda,0x75,0xf0,0x00,0xc2,0x4d,0x02,0x72,0x0f,0x14,0x64,0x80,0xe0,
  0x6d,0x02,0x05,0x0a,0x12,0x20,0x36,0xb0,0xe0,0x20,0x81,0xb1,0x8f,0x23,0xfb,0xad,
  0xdc,0x70,0x00,0x62,0x02,0x7d,0x0d,0x28,0xb6,0x28,0x30,0x80,0x00,0x01,0x74,0x49,
  0xab,0x16,0x18,0x10,0x00,0x3b
  };

/* Generated by reswrap from file GreenTick.gif */
const unsigned char GreenTick[]={
  0x47,0x49,0x46,0x38,0x39,0x61,0x12,0x00,0x12,0x00,0x87,0x00,0x00,0x00,0x82,0x84,
  0x7b,0xae,0x73,0x21,0x79,0x10,0x18,0x71,0x08,0x18,0x71,0x10,0x73,0xa6,0x6b,0x21,
  0x7d,0x08,0x21,0x7d,0x00,0x18,0x79,0x00,0x18,0x75,0x00,0x10,0x71,0x00,0x10,0x6d,
  0x00,0x10,0x6d,0x08,0x6b,0xa6,0x6b,0x4a,0x92,0x42,0x29,0x86,0x00,0x39,0x8e,0x21,
  0x52,0x9a,0x39,0x42,0x8a,0x39,0x31,0x8e,0x08,0x42,0x92,0x21,0xe7,0xf3,0xe7,0xff,
  0xff,0xff,0x5a,0x9e,0x39,0x21,0x82,0x00,0x31,0x8a,0x10,0x4a,0x9e,0x21,0xef,0xf3,
  0xe7,0x94,0xbe,0x8c,0xbd,0xdb,0xad,0x29,0x8a,0x00,0x84,0xb2,0x84,0xbd,0xd7,0xad,
  0x39,0x92,0x18,0x84,0xba,0x5a,0x4a,0xa2,0x08,0x94,0xc7,0x73,0x4a,0xa6,0x08,0x6b,
  0xae,0x39,0x52,0xaa,0x08,0x52,0xa6,0x08,0x39,0x92,0x08,0x52,0xa2,0x21,0x9c,0xc3,
  0x8c,0x7b,0xb2,0x5a,0x8c,0xb6,0x84,0x5a,0xaa,0x18,0x5a,0xb2,0x08,0x5a,0xae,0x08,
  0x4a,0x96,0x21,0x84,0xb2,0x7b,0x63,0xb6,0x10,0xbd,0xd3,0xb5,0x6b,0xaa,0x4a,0x42,
  0x9a,0x08,0x39,0x8e,0x10,0x8c,0xba,0x7b,0x4a,0x9a,0x29,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x21,0xf9,0x04,
  0x03,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x12,0x00,0x12,0x00,0x00,0x08,
  0xd8,0x00,0x01,0x08,0x1c,0x48,0xb0,0xa0,0xc1,0x81,0x38,0x72,0x84,0x08,0x01,0x41,
  0xc6,0xc1,0x81,0x32,0x5c,0x9c,0x28,0x51,0x62,0x44,0x8a,0x14,0x37,0x02,0x08,0xb4,
  0x40,0xb0,0xc6,0x8c,0x17,0x27,0x50,0x54,0xb4,0x71,0x71,0x82,0x03,0x0b,0x1c,0x05,
  0xca,0xf8,0x08,0xe3,0xc4,0x89,0x11,0x16,0x53,0x4c,0xf0,0x60,0x81,0x06,0x41,0x17,
  0x2f,0x60,0xc0,0x10,0x59,0xf1,0x62,0x0c,0x0b,0x20,0x0c,0x0c,0x5c,0xe1,0xd2,0xa5,
  0x48,0x98,0x29,0x58,0x00,0xc5,0x70,0xa0,0x85,0x40,0x0d,0x25,0x42,0x52,0xb4,0xa8,
  0xa2,0x83,0x85,0x0e,0x0f,0x30,0x20,0x10,0x20,0x30,0x04,0xc5,0x8a,0x30,0x4d,0x54,
  0x00,0xfa,0xe0,0xc1,0x01,0x04,0x03,0xba,0x8a,0xb8,0x0a,0x93,0x04,0xca,0x0e,0x1e,
  0xb2,0x22,0x48,0x40,0x40,0x20,0x04,0xab,0x57,0xf1,0x82,0x88,0x6b,0x36,0x81,0x82,
  0xba,0x00,0x38,0x68,0xd8,0x80,0xf2,0x2d,0xdf,0xb3,0x09,0x16,0x7c,0x18,0x98,0x41,
  0xc3,0x58,0x0b,0x1b,0xca,0x9a,0x3d,0x90,0x98,0x01,0xc1,0x00,0x13,0x28,0x8c,0xbd,
  0x90,0x15,0xf1,0x82,0x05,0x0d,0x0a,0x3a,0x78,0x00,0x21,0xc2,0x81,0xd3,0x09,0x12,
  0x2f,0x90,0x70,0x30,0x80,0x01,0xc4,0x7e,0x17,0x30,0x08,0xfd,0x10,0x40,0x00,0x01,
  0x03,0x08,0x10,0x28,0x50,0xbb,0x77,0xc1,0x80,0x00,0x3b
  };



class TestWindow : public FXMainWindow
{
	FXDECLARE(TestWindow)
public:
	int svnrev;
	FXString mypath, TnFOXpath, TnFOXver, FOXver, hostOS, hostOSDescription;
	FXString kernelname, kernelversion, architecture;
	struct Platform
	{
		FXint id;
		FXString kernelname, kernelversion, architecture, tnfoxver, foxver;
		FXString description() const
		{
			return FXString("%1 %2\n%3\n%4_%5").arg(kernelname).arg(kernelversion).arg(architecture).arg(tnfoxver).arg(foxver);
		}
	};
	QMemArray<Platform> columns;

	FXGIFIcon *greentick, *redexclamation;
	FXTable *tests;
	struct TestResults
	{
		FXText *info;
        FXText *output;
		FXFont *monospaced;
	} testresults;
	FXPrimaryButton *runtests;
public:
	enum
	{
		ID_FILLINTESTS=FXMainWindow::ID_LAST,
		ID_CHANGETEST,
		ID_RUNTESTS,
		ID_LAST
	};
protected:
	TestWindow() { }
public:
	TestWindow(FXApp *app) : FXMainWindow(app, QTrans::tr("TestWindow", "TnFOX Automated Tester"), NULL, NULL, DECOR_ALL, 50, 50, 800, 800)
	{
		FXProcess::buildInfo(&svnrev);
		mypath=FXProcess::execpath();
		TnFOXpath=mypath.left(mypath.find("lib")-1);
		TnFOXver=FXString("v%1.%2"); TnFOXver.arg(TNFOX_MAJOR).arg(TNFOX_MINOR);
		FOXver=FXString("v%1.%2.%3"); FOXver.arg(FOX_MAJOR).arg(FOX_MINOR).arg(FOX_LEVEL);
		hostOS=FXProcess::hostOS();
		{
			FXProcess::hostOSDescription(0, &kernelname,
#ifdef WIN32
				0,
				&kernelversion,
#else
				&kernelversion,
				0,
#endif
				&architecture);
			hostOSDescription="%1 %2 v%3";
			hostOSDescription.arg(architecture).arg(kernelname).arg(kernelversion);
		}

		greentick=new FXGIFIcon(app, GreenTick);
		redexclamation=new FXGIFIcon(app, RedExclamation);
		FXFontDesc *fonts=0;
		FXuint numfonts;
#if FOX_MAJOR>1 || (FOX_MAJOR==1 && FOX_MINOR>4)
		if(FXFont::listFonts(fonts, numfonts, "", 0, FXFont::Straight,
							 0, FONTENCODING_DEFAULT, FXFont::Scalable))
#else
		if(FXFont::listFonts(fonts, numfonts, "", FONTWEIGHT_DONTCARE, FONTSLANT_REGULAR,
							 FONTSETWIDTH_DONTCARE, FONTENCODING_DEFAULT, FONTHINT_SCALABLE))
#endif
		{
			int score=32;
			FXString best;
			for(FXuint n=0; n<numfonts; n++)
			{
				FXFontDesc &f=fonts[n];
				FXString face(f.face);
				fxmessage("Candidate font: %s\n", face.text());
				if(!comparecase(face, "courier new", 11)) { best="courier new,80,normal,normal"; score=0; }
				else if(score>1 && !comparecase(face, "courier", 7)) { best="courier,80,normal,normal"; score=1; }
				else if(score>2 && !comparecase(face, "luxi mono", 9)) { best="luxi mono,80,normal,normal"; score=2; }
				else if(score>3 && !comparecase(face, "freemono", 8)) { best="freemono,80,normal,normal"; score=3; }
			}
			FXFREE(&fonts);
			testresults.monospaced=new FXFont(app, best);
		}

		FXVerticalFrame *f1=new FXVerticalFrame(this, LAYOUT_FILL);
		FXGroupBox *sysinfo=new FXGroupBox(f1, tr("System Information:"), LAYOUT_FILL_X|FRAME_RIDGE);
		FXMatrix *si=new FXMatrix(sysinfo, 2, MATRIX_BY_COLUMNS|LAYOUT_FILL);
		new FXLabel(si, tr("TnFOX path:"), 0, JUSTIFY_RIGHT|LAYOUT_FILL_X);
		FXText *tnfoxpath=new FXText(si, 0, 0, TEXT_READONLY|LAYOUT_FILL|LAYOUT_FILL_COLUMN);
		tnfoxpath->setVisibleRows(1);
		tnfoxpath->setText(tr("%1 (my path: %2)").arg(TnFOXpath).arg(mypath));
		new FXLabel(si, tr("TnFOX version:"), 0, JUSTIFY_RIGHT|LAYOUT_FILL_X);
		FXText *tnfoxver=new FXText(si, 0, 0, TEXT_READONLY|LAYOUT_FILL|LAYOUT_FILL_COLUMN);
		tnfoxver->setVisibleRows(1);
		tnfoxver->setText(TnFOXver+" (SVN rev: "+FXString::number(svnrev)+")");
		new FXLabel(si, tr("Based on FOX version:"), 0, JUSTIFY_RIGHT|LAYOUT_FILL_X);
		FXText *foxver=new FXText(si, 0, 0, TEXT_READONLY|LAYOUT_FILL|LAYOUT_FILL_COLUMN);
		foxver->setVisibleRows(1);
		foxver->setText(FOXver);
		new FXLabel(si, tr("Built for Host:"), 0, JUSTIFY_RIGHT|LAYOUT_FILL_X);
		FXText *hostos=new FXText(si, 0, 0, TEXT_READONLY|LAYOUT_FILL|LAYOUT_FILL_COLUMN);
		hostos->setVisibleRows(1);
		hostos->setText(hostOS);
		new FXLabel(si, tr("Host Operating System:"), 0, JUSTIFY_RIGHT|LAYOUT_FILL_X);
		FXText *hostosd=new FXText(si, 0, 0, TEXT_READONLY|LAYOUT_FILL|LAYOUT_FILL_COLUMN);
		hostosd->setVisibleRows(1);
		hostosd->setText(hostOSDescription);

		FXFSMonitor::add(FXPath::directory(mypath), FXFSMonitor::ChangeHandler(*this, &TestWindow::invokeFillInTests));

		FXGroupBox *testgroup=new FXGroupBox(f1, tr("Tests:"), LAYOUT_FILL|FRAME_RIDGE);
		FXSplitter *tg1=new FXSplitter(testgroup, SPLITTER_VERTICAL|SPLITTER_TRACKING|SPLITTER_REVERSED|LAYOUT_FILL);
		tests=new FXTable(tg1, this, ID_CHANGETEST, TABLE_COL_SIZABLE|TABLE_ROW_SIZABLE|TABLE_READONLY|LAYOUT_FILL);
		onCmdFillInTests(0, 0, 0);
		FXVerticalFrame *tg2=new FXVerticalFrame(tg1, LAYOUT_FILL);
		testresults.info=new FXText(tg2, 0, 0, LAYOUT_FILL_X);
		testresults.info->setVisibleRows(3);
		testresults.output=new FXText(tg2, 0, 0, LAYOUT_FILL);
		testresults.output->setText("I am a teapot, short and stout!\nHere is my handle, here is my spout.\nLift me up, and pour me out!");
		testresults.output->setFont(testresults.monospaced);
		testresults.output->setVisibleRows(8);
		tests->selectRange(0, 0, tests->getNumColumns()==2 ? 1 : 2, tests->getNumColumns()==2 ? 1 : 2);

		FXGroupBox *tasksgroup=new FXGroupBox(f1, tr("Tasks:"), LAYOUT_FILL_X|FRAME_RIDGE);
		runtests=new FXPrimaryButton(tasksgroup, tr("Run Tests!"), 0, this, ID_RUNTESTS, PBUTTON_NORMAL|FXWindow::userHandednessLayout());

		onCmdChangeTest(0, 0, 0);
	}
	~TestWindow()
	{
	}
	void invokeFillInTests(FXFSMonitor::Change change, const QFileInfo &oldfi, const QFileInfo &newfi)
	{
		if(oldfi.isExecutable() || newfi.isExecutable())
		{
			getEventLoop()->postAsyncMessage(this, FXSEL(SEL_COMMAND, TestWindow::ID_FILLINTESTS));
		}
	}

	FXAutoPtr<TnFXSQLDB> openResults()
	{
		FXString dbname=FXPath::join(TnFOXpath, "TestResults.sqlite3");
		bool exists=FXStat::exists(dbname)!=0;
		FXAutoPtr<TnFXSQLDB> mydb=TnFXSQLDBRegistry::make("SQLite3", dbname);
		mydb->open();
		if(!exists)
		{
			mydb->immediate("CREATE TABLE 'platforms'('id' INTEGER PRIMARY KEY, 'tnfoxver' VARCHAR(24), 'foxver' VARCHAR(10), 'architecture' VARCHAR(16), 'kernelname' VARCHAR(16), 'kernelversion' VARCHAR(32));");
			mydb->immediate("CREATE TABLE 'results'('id' INTEGER PRIMARY KEY, 'testname' VARCHAR(32), 'started' TIMESTAMP, 'ended' TIMESTAMP, 'platform' INTEGER, 'svnrev' INTEGER, 'returncode' INTEGER, 'output' BLOB, FOREIGN KEY ('platform') REFERENCES 'platforms' ('id'));");
		}
		return mydb;
	}


	long onCmdFillInTests(FXObject *from, FXSelector sel, void *ptr);
	long onCmdChangeTest(FXObject *from, FXSelector sel, void *ptr);
	void appendOutput(QChildProcess &child, bool terminate);
	long onCmdRunTests(FXObject *from, FXSelector sel, void *ptr);
};


FXDEFMAP(TestWindow) TestWindowMap[]={
	FXMAPFUNC(SEL_COMMAND,   TestWindow::ID_FILLINTESTS, TestWindow::onCmdFillInTests),
	FXMAPFUNC(SEL_SELECTED,  TestWindow::ID_CHANGETEST,  TestWindow::onCmdChangeTest),
	FXMAPFUNC(SEL_COMMAND,   TestWindow::ID_RUNTESTS,    TestWindow::onCmdRunTests),
};

FXIMPLEMENT(TestWindow, FXMainWindow, TestWindowMap, ARRAYNUMBER(TestWindowMap))



struct TestResult
{
	FXString testname;
	FXTime started, ended;
	struct Version
	{
		FXString TnFOX, FOX;
		FXuint svnrev;
	} version;
	FXString architecture, kernelname, kernelversion;
	FXlong returncode;
	FXString output;

	// Not stored
	FXint myPlatformId;
	FXint totalRecords;
public:
	TestResult() : returncode(0), myPlatformId(-1) { }
	TestResult(TestWindow *base, const FXString &_testname)
		: testname(_testname), started(FXTime::now()), ended(0, false),
		architecture(base->architecture), kernelname(base->kernelname), kernelversion(base->kernelversion),
		returncode(0), myPlatformId(-1), totalRecords(-1)
	{
		version.TnFOX=base->TnFOXver;
		version.FOX=base->FOXver;
		version.svnrev=base->svnrev;
	}


	FXint findMyPlatformId(TnFXSQLDB *db, bool createIfNotPresent=false)
	{	// Returns a platform id
		FXint ret=-1;
		TnFXSQLDBStatementRef s=db->prepare("SELECT id FROM 'platforms' WHERE tnfoxver=? AND foxver=? AND architecture=? AND kernelname=? AND kernelversion=?;");
		s->bind(0, version.TnFOX).bind(1, version.FOX).bind(2, architecture).bind(3, kernelname).bind(4, kernelversion);
		TnFXSQLDBCursorRef c=s->execute();
		if(c->atEnd())
		{
			if(createIfNotPresent)
			{
				s=db->prepare("INSERT INTO 'platforms'('tnfoxver', 'foxver', 'architecture', 'kernelname', 'kernelversion') VALUES(?, ?, ?, ?, ?);");
				s->bind(0, version.TnFOX).bind(1, version.FOX).bind(2, architecture).bind(3, kernelname).bind(4, kernelversion);
				s->execute();
				return findMyPlatformId(db);
			}
			return ret;
		}
		c->data(0)->get<FXint>(ret);
		c->next();
		FXERRH(c->atEnd(), QTrans::tr("TestWindow", "Database table 'platforms' is ambiguous"), 0, 0);
		return (myPlatformId=ret);
	}
	TnFXSQLDBStatementRef &bind(TnFXSQLDBStatementRef &st)
	{
		st->bind(":testname", testname);
		st->bind(":started", started);
		st->bind(":ended", ended);
		st->bind(":platform", myPlatformId);
		st->bind(":svnrev", version.svnrev);
		st->bind(":returncode", returncode);
		st->bind(":output", output);
		return st;
	}
	TnFXSQLDBCursorRef &get(TnFXSQLDBCursorRef &cur, bool loadOutput=true)
	{
		cur->data(1)->get<>(testname);
		cur->data(2)->get<>(started);
		cur->data(3)->get<>(ended);
		cur->data(4)->get<>(myPlatformId);
		cur->data(5)->get<>(version.svnrev);
		cur->data(6)->get<>(returncode);
		if(loadOutput) cur->data(7)->get<>(output);
		return cur;
	}
	void insert(TnFXSQLDB *db)
	{
		if(-1==myPlatformId)
			findMyPlatformId(db, true);
		assert(myPlatformId>=0);
		TnFXSQLDBStatementRef st=db->prepare("INSERT INTO 'results'('testname', 'started', 'ended', 'platform', 'svnrev', 'returncode', 'output') VALUES(:testname, :started, :ended, :platform, :svnrev, :returncode, :output);");
		bind(st);
		st->execute();
	}
	bool load(TnFXSQLDB *db, TestWindow *w, int r, int c, bool loadOutput=true)
	{
		testname=w->tests->getItemText(r, 0);
		const TestWindow::Platform &pf=w->columns[c-2];
		for(TnFXSQLDBCursorRef c=db->execute("SELECT * FROM 'results' WHERE testname='"+testname+"' AND platform="+FXString::number(pf.id)+" ORDER BY ended DESC;"); !c->atEnd(); c->next())
		{
			get(c, loadOutput);
			if(loadOutput)
			{	// Also fetch the platform info
				c=db->execute("SELECT * FROM 'platforms' WHERE id="+FXString::number(myPlatformId)+";");
				c->data(1)->get<>(version.TnFOX);
				c->data(2)->get<>(version.FOX);
				c->data(3)->get<>(architecture);
				c->data(4)->get<>(kernelname);
				c->data(5)->get<>(kernelversion);
			}
			for(totalRecords=0; !c->atEnd(); c->next(), ++totalRecords);
			return true;
		}
		return false;
	}
	FXString info()
	{
		FXTime _started(started), _ended(ended);
		return QTrans::tr("TestWindow", "Output of %1 run on %2 %3 %4\nStarted: %5, Ended: %6, Duration: %7 secs\nReturn Code: %8 (%9)")
			.arg(testname).arg(architecture).arg(kernelname).arg(kernelversion)
			.arg(_started.toLocalTime().asString()).arg(_ended.toLocalTime().asString()).arg((double)(ended.value-started.value)/FXTime::micsPerSecond)
			.arg(returncode).arg(returncode ? QTrans::tr("TestWindow", "FAILED!") : QTrans::tr("TestWindow", "PASSED!"));
	}
	//friend FXStream &operator<<(FXStream &s, const TestResult &i);
	//friend FXStream &operator>>(FXStream &s, TestResult &i);
};
/*FXStream &operator<<(FXStream &s, const TestResult &i)
{
	s << (FXuchar) 0;	// version
	s <<
}
FXStream &operator>>(FXStream &s, TestResult &i)
{
}*/

long TestWindow::onCmdFillInTests(FXObject *from, FXSelector sel, void *ptr)
{	/* We have three core columns, Test Name, Executable Status, and this host OS (ie; column 2)

	Thereafter we have results from the database, one per platform

CREATE TABLE 'platforms'('id' INTEGER PRIMARY KEY, 'tnfoxver' VARCHAR(24), 'foxver' VARCHAR(10), 'architecture' VARCHAR(16), 'kernelname' VARCHAR(16), 'kernelversion' VARCHAR(32));
CREATE TABLE 'results'('id' INTEGER PRIMARY KEY, 'testname' VARCHAR(32), 'started' TIMESTAMP, 'ended' TIMESTAMP, 'platform' INTEGER FOREIGN KEY REFERENCES 'platforms' ('id'), 'svnrev' INTEGER, 'returncode' INTEGER, 'output' BLOB));
	*/
	int n, platformid;
	tests->clearItems();
	tests->setRowHeaderWidth(0);
	tests->setColumnHeaderHeight(50);
	tests->insertColumns(0); tests->setColumnText(0, tr("Test:"));
	tests->insertColumns(1); tests->setColumnText(1, tr("Executable Status:")); tests->setColumnWidth(1, 130);

	FXAutoPtr<TnFXSQLDB> mydb=openResults();
	columns.resize(0);
	n=2;
	{
		TestResult test(this, FXString::nullStr());
		platformid=test.findMyPlatformId(PtrPtr(mydb), true);
		Platform pf;
		pf.id=platformid;
		pf.tnfoxver=TnFOXver;
		pf.foxver=FOXver;
		pf.architecture=architecture;
		pf.kernelname=kernelname;
		pf.kernelversion=kernelversion;
		columns.push_back(pf);
		tests->insertColumns(n);
		tests->setColumnText(n, pf.description());
		tests->setColumnWidth(n, 130);
		n++;
	}
	for(TnFXSQLDBCursorRef c=mydb->execute("SELECT * FROM 'platforms' WHERE tnfoxver='"+TnFOXver+"' ORDER BY 'kernelname','kernelversion','architecture','foxver';"); !c->atEnd(); c->next())
	{
		Platform pf;
		c->data(0)->get<>(pf.id);
		if(pf.id!=platformid)
		{
			c->data(1)->get<>(pf.tnfoxver);
			c->data(2)->get<>(pf.foxver);
			c->data(3)->get<>(pf.architecture);
			c->data(4)->get<>(pf.kernelname);
			c->data(5)->get<>(pf.kernelversion);
			columns.push_back(pf);
			tests->insertColumns(n);
			tests->setColumnText(n, pf.description());
			tests->setColumnWidth(n, 130);
			n++;
		}
	}

	QDir testsuite(FXPath::join(TnFOXpath, "TestSuite"), "Test*");
	FXString builddir=FXPath::directory(mypath);
	n=0;
	for(QFileInfoList::const_iterator it1=testsuite.entryInfoList()->begin(); it1!=testsuite.entryInfoList()->end(); ++it1)
	{
		const QFileInfo &fi=*it1;
		if(fi.isDir() && FXStat::exists(FXPath::join(fi.filePath(), "SConstruct")))
		{
			tests->insertRows(n);
			tests->setItemText(n, 0, fi.fileName());
			QFileInfo exefi(FXPath::join(builddir, fi.fileName()));
			if(!exefi.isExecutable()) exefi.setFile(exefi.filePath()+".exe");
			if(exefi.isExecutable())
			{
				FXTime lastModified=exefi.lastModified();
				FXString s(lastModified.toLocalTime().asString("%Y/%m/%d %H:%M:%S"));
				QFileInfo mainfi(FXPath::join(fi.filePath(), "main.cpp"));
				if(mainfi.lastModified()>exefi.lastModified())
				{
					s.append(tr("\nNeeds rebuilding!"));
					tests->setItemIcon(n, 1, redexclamation);
				}
				else
				{
					s.append(tr("\nUp to date!"));
					tests->setItemIcon(n, 1, greentick);
				}
				tests->setItemText(n, 1, s);
				tests->setRowHeight(n, 40);
			}
			else
			{
				tests->setItemText(n, 1, tr("Missing!"));
				tests->setItemIcon(n, 1, 0);
			}
			tests->setItemIconPosition(n, 1, FXTableItem::AFTER);

			TestResult test;
			for(int col=2; col<tests->getNumColumns(); col++)
			{
				if(test.load(PtrPtr(mydb), this, n, col, false))
				{
					FXTime ended=test.ended;
					tests->setItemText(n, col, ended.toLocalTime().asString("%Y/%m/%d %H:%M:%S")
						+"\n"+FXString::number(test.returncode)
						+"\nRecords: "+FXString::number(test.totalRecords)+" (rev "+FXString::number(test.version.svnrev)+")");
					tests->setItemIcon(n, col, test.returncode ? redexclamation : greentick);
					tests->setItemIconPosition(n, col, FXTableItem::AFTER);
				}
			}
			n++;
		}
	}
	return 1;
}

long TestWindow::onCmdChangeTest(FXObject *from, FXSelector sel, void *ptr)
{
	bool fill=false, runtest=false;
	int col=tests->getSelStartColumn(), row=tests->getSelStartRow();
	if(col>=2 && col==tests->getSelEndColumn())
	{
		if(2==col)
		{
			runtest=true;
			for(int row=tests->getSelStartRow(); row<=tests->getSelEndRow(); row++)
			{
				if(tests->getItemIcon(row, 1)==redexclamation)
				{
					runtest=false;
					break;
				}
			}
		}
		if(row==tests->getSelEndRow() && tests->getItemIcon(row, col)) fill=true;
	}
	if(fill)
	{
		FXAutoPtr<TnFXSQLDB> mydb=openResults();
		TestResult test;
		test.load(PtrPtr(mydb), this, row, col);
		testresults.info->setText(test.info());
		testresults.output->setText(test.output);
	}
	else
	{
		testresults.info->setText(FXString::nullStr());
		testresults.output->setText(FXString::nullStr());
	}
	if(runtest) runtests->enable(); else runtests->disable();
	return 1;
}

void TestWindow::appendOutput(QChildProcess &child, bool terminate)
{
	char buffer[4096], *buff;
	QIODeviceS *dev=&child;
	bool timedout;
	while(!(timedout=!QIODeviceS::waitForData(0, 1, &dev, 30000)))
	{
		FXuval read;
		buff=buffer;
		if((read=child.readBlock(buff, sizeof(buffer)-(buff-buffer))))
		{
			FXuval inputlen=read+(buff-buffer);
			FXuchar output[4096];
			read=QIODevice::removeCRLF(output, (FXuchar *) buffer, sizeof(output), inputlen);
			memmove(buffer, buffer+inputlen, sizeof(buffer)-inputlen);
			buff=buffer+sizeof(buffer)-inputlen;
			testresults.output->appendText((FXchar *) output, read);
			testresults.output->makePositionVisible(testresults.output->getLength());
			getApp()->runWhileEvents();
		}
		else break;
	}
	if(timedout)
	{
		FXString msg("<timed out>\n");
		testresults.output->appendText(msg.text(), msg.length());
		if(terminate)
		{
			child.terminate();
			FXString msg("<terminated>\n");
			testresults.output->appendText(msg.text(), msg.length());
		}
	}
}

long TestWindow::onCmdRunTests(FXObject *from, FXSelector sel, void *ptr)
{
	FXRectangle selection(tests->getSelStartRow(), tests->getSelStartColumn(), tests->getSelEndRow(), tests->getSelEndColumn());
	int col=tests->getSelStartColumn();
	FXString builddir=FXPath::directory(mypath);
	for(int row=tests->getSelStartRow(); row<=tests->getSelEndRow(); row++)
	{
		if(tests->getItemIcon(row, 1)==greentick)
		{
			FXString testpath(FXPath::join(builddir, tests->getItemText(row, 0))), workingdir(FXPath::directory(testpath));
			if(!FXStat::exists(testpath)) testpath.append(".exe");
			QChildProcess child(testpath, "-automatedtest");
			if(workingdir.right(5)==".libs") workingdir.truncate(workingdir.length()-6);
			child.setWorkingDir(workingdir);
			getApp()->beginWaitCursor();
			TestResult test(this, tests->getItemText(row, 0));
			FXERRH_TRY
			{
				child.open();
				testresults.info->setText(tr("Started: %1").arg(test.started.asString()));
				child.setReadChannel(QChildProcess::StdOut);
				testresults.output->setText(FXString::nullStr());
				appendOutput(child, false);
				testresults.output->appendText("\n\n\nStdErr:\n\n", 12);
				child.setReadChannel(QChildProcess::StdErr);
				appendOutput(child, true);
			}
			FXERRH_CATCH(FXException &e)
			{
				FXERRH_REPORT(this, e);
			}
			FXERRH_ENDTRY
			child.close();
			test.ended=FXTime::now();
			test.returncode=child.returnCode();
			if(testresults.output->getText().empty())
				testresults.output->setText(tr("<no output>"));
			test.output=testresults.output->getText();

			{	// Stuff it into the database
				FXAutoPtr<TnFXSQLDB> mydb=openResults();
				TnFXSQLDBTransaction undoadd(mydb);
				test.insert(PtrPtr(mydb));
				undoadd.commit();
			}
			getApp()->endWaitCursor();

			tests->setItemText(row, col, FXString::number(test.returncode)+"\n(rev "+FXString::number(test.version.svnrev)+")");
			tests->setItemIcon(row, col, test.returncode ? redexclamation : greentick);
			tests->setItemIconPosition(row, col, FXTableItem::AFTER);
		}
	}
	onCmdFillInTests(from, sel, ptr);
	tests->selectRange(selection.x, selection.w, selection.y, selection.h);
	onCmdChangeTest(from, sel, ptr);
	return 1;
}


int main( int argc, char *argv[] )
{
	FXProcess myprocess(argc, argv);
	FXApp app("TnFOX Automated Tester");
	app.init(argc, argv);
	
	TestWindow *win = new TestWindow(&app);
	
	app.create();
	win->show(PLACEMENT_SCREEN);
	
	return app.run();
}
